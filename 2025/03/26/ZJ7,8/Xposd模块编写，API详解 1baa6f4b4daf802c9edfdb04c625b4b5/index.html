

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/CC.png">
  <link rel="icon" href="/img/CC.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CC">
  <meta name="keywords" content="">
  
    <meta name="description" content="Xposd模块编写，API详解1.什么是Xposed？Xposed是一款可以在不修改APK的情况下影响程序运行的框架，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。在这个框架下，我们可以编写并加载自己编写的插件APP，实现对目标apk的注入拦截等。  核心功能 动态Hook：无需修改APK即可拦截和修改目标方法的执行逻辑，例如改变返回值、插入代码等38。 模块化扩展：开发者可">
<meta property="og:type" content="article">
<meta property="og:title" content="Xposd模块编写，API详解">
<meta property="og:url" content="https://cc-nx.github.io/2025/03/26/ZJ7,8/Xposd%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%EF%BC%8CAPI%E8%AF%A6%E8%A7%A3%201baa6f4b4daf802c9edfdb04c625b4b5/index.html">
<meta property="og:site_name" content="CC₍ᐢ..ᐢ₎♡">
<meta property="og:description" content="Xposd模块编写，API详解1.什么是Xposed？Xposed是一款可以在不修改APK的情况下影响程序运行的框架，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。在这个框架下，我们可以编写并加载自己编写的插件APP，实现对目标apk的注入拦截等。  核心功能 动态Hook：无需修改APK即可拦截和修改目标方法的执行逻辑，例如改变返回值、插入代码等38。 模块化扩展：开发者可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059490.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100155.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100386.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100074.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100371.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100372.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101716.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101026.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262102101.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262103369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262103041.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262103920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104375.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104386.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104942.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262105799.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106768.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106121.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106592.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107135.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107894.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107874.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107778.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107682.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108404.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108154.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108773.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109554.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109960.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109835.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110935.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110214.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110524.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110526.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111522.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111688.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111531.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111017.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111492.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112026.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112296.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112559.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262113404.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262113351.png">
<meta property="article:published_time" content="2025-03-26T04:54:40.000Z">
<meta property="article:modified_time" content="2025-03-26T13:13:24.491Z">
<meta property="article:author" content="CC">
<meta property="article:tag" content="Frida">
<meta property="article:tag" content="Xposd">
<meta property="article:tag" content="API">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059416.png">
  
  
  
  <title>Xposd模块编写，API详解 - CC₍ᐢ..ᐢ₎♡</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"cc-nx.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CC₍ᐢ..ᐢ₎♡</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/123.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Xposd模块编写，API详解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-26 12:54" pubdate>
          2025年3月26日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          132 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Xposd模块编写，API详解</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Xposd模块编写，API详解"><a href="#Xposd模块编写，API详解" class="headerlink" title="Xposd模块编写，API详解"></a>Xposd模块编写，API详解</h1><h2 id="1-什么是Xposed？"><a href="#1-什么是Xposed？" class="headerlink" title="1.什么是Xposed？"></a><strong>1.什么是Xposed？</strong></h2><p>Xposed是一款可以在不修改APK的情况下影响程序运行的框架，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。在这个框架下，我们可以编写并加载自己编写的插件APP，实现对目标apk的注入拦截等。</p>
<ul>
<li>核心功能<ol>
<li><strong>动态Hook</strong>：无需修改APK即可拦截和修改目标方法的执行逻辑，例如改变返回值、插入代码等38。</li>
<li><strong>模块化扩展</strong>：开发者可通过编写模块（Module）实现功能扩展，模块间相互独立且可同时运行46。</li>
<li><strong>系统级控制</strong>：能够干预系统核心进程（如Zygote），影响所有应用的运行环境</li>
</ol>
</li>
</ul>
<h2 id="2-Xposed原理"><a href="#2-Xposed原理" class="headerlink" title="2.Xposed原理"></a><strong>2.Xposed原理</strong></h2><p>用自己实现的<strong>app_process</strong>替换掉了系统原本提供的<strong>app_process</strong>，加载一个额外的jar包，入口从原来的：&nbsp;&nbsp;<strong>com.android.internal.osZygoteInit.main()被替换成了：&nbsp;&nbsp;de.robv.android.xposed.XposedBridge.main()</strong>，</p>
<p>创建的Zygote进程就变成Hook的Zygote进程了，从而完成对zygote进程及其创建的Dalvik/ART虚拟机的劫持(zytoge注入)</p>
<p><img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059416.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>文字解释</p>
<h3 id="1-劫持Zygote进程"><a href="#1-劫持Zygote进程" class="headerlink" title="(1) 劫持Zygote进程"></a><strong>(1) 劫持Zygote进程</strong></h3><ul>
<li><strong>Zygote的作用</strong>：Android系统中所有应用进程均由Zygote进程孵化而来。Xposed通过替换系统文件<code>/system/bin/app_process</code>，在Zygote启动时加载自定义的<code>XposedBridge.jar</code>，从而接管Zygote的初始化流程。</li>
<li><strong>注入逻辑</strong>：修改后的<code>app_process</code>会优先执行<code>XposedBridge.main()</code>，而非原生的<code>ZygoteInit.main()</code>。此时，Xposed框架完成Hook机制的初始化，并加载所有启用的模块。</li>
</ul>
<h3 id="2-Hook机制实现"><a href="#2-Hook机制实现" class="headerlink" title="(2) Hook机制实现"></a><strong>(2) Hook机制实现</strong></h3><ul>
<li><strong>方法替换</strong>：Xposed将目标Java方法标记为Native方法，并将其实现指向自定义的<code>xposedCallHandler</code>函数。当方法被调用时，控制权会转移到Xposed框架，执行模块中定义的<code>beforeHookedMethod</code>和<code>afterHookedMethod</code>回调89。</li>
<li><strong>回调链管理</strong>：若多个模块Hook同一方法，Xposed会根据优先级排序执行回调，顺序为：<code>A.before → B.before → 原方法 → B.after → A.after</code>。</li>
</ul>
<h3 id="3-模块加载与执行"><a href="#3-模块加载与执行" class="headerlink" title="(3) 模块加载与执行"></a><strong>(3) 模块加载与执行</strong></h3><ul>
<li><strong>模块入口</strong>：每个Xposed模块需在<code>AndroidManifest.xml</code>中声明<code>xposedmodule</code>元数据，并通过<code>xposed_init</code>文件指定入口类。框架在Zygote启动时加载这些模块，并在目标应用启动时触发Hook逻辑34。</li>
<li><strong>API支持</strong>：通过<code>XposedHelpers</code>和<code>XposedBridge</code>等工具类，开发者可便捷地定位目标类与方法，例如使用<code>findAndHookMethod</code>实现方法拦截。</li>
</ul>
</li>
</ul>
<h3 id="3-Xposed的发展及免root框架"><a href="#3-Xposed的发展及免root框架" class="headerlink" title="3.Xposed的发展及免root框架"></a><strong>3.Xposed的发展及免root框架</strong></h3><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>地址</strong></th>
<th><strong>支持版本</strong></th>
<th><strong>是否免root</strong></th>
</tr>
</thead>
<tbody><tr>
<td>xposed</td>
<td><a target="_blank" rel="noopener" href="https://github.com/rovo89/Xposed">https://github.com/rovo89/Xposed</a></td>
<td>2.3-8.1</td>
<td>否</td>
</tr>
<tr>
<td>EDXposed</td>
<td><a target="_blank" rel="noopener" href="https://github.com/ElderDrivers/EdXposed">https://github.com/ElderDrivers/EdXposed</a></td>
<td>8.0-10</td>
<td>否</td>
</tr>
<tr>
<td>LSPosed</td>
<td><a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPosed">https://github.com/LSPosed/LSPosed</a></td>
<td>8.1-13</td>
<td>否</td>
</tr>
<tr>
<td>VirtualXposed</td>
<td><a target="_blank" rel="noopener" href="https://github.com/android-hacker/VirtualXposed">https://github.com/android-hacker/VirtualXposed</a></td>
<td>5.0-10.0</td>
<td>是</td>
</tr>
<tr>
<td>太极</td>
<td><a target="_blank" rel="noopener" href="https://www.coolapk.com/apk/me.weishu.exp">https://www.coolapk.com/apk/me.weishu.exp</a></td>
<td>5.0-13</td>
<td>是</td>
</tr>
<tr>
<td>两仪</td>
<td><a target="_blank" rel="noopener" href="https://www.coolapk.com/apk/io.twoyi">https://www.coolapk.com/apk/io.twoyi</a></td>
<td>8.1-13</td>
<td>是</td>
</tr>
<tr>
<td>天鉴</td>
<td><a target="_blank" rel="noopener" href="https://github.com/Katana-Official/SPatch-Update">https://github.com/Katana-Official/SPatch-Update</a></td>
<td>6-10</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="4-Xposed可以做什么？"><a href="#4-Xposed可以做什么？" class="headerlink" title="4.Xposed可以做什么？"></a><strong>4.Xposed可以做什么？</strong></h3><p>1.修改app布局:<a target="_blank" rel="noopener" href="https://github.com/kaisar945/Xposed-GodMode">上帝模式</a></p>
<p>2.劫持数据，修改参数值、返回值、主动调用等。例:微信防撤回、步数修改、一键新机</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kingsollyu/AppEnv">应用变量</a></p>
<p>3.自动化操作，例:微信抢红包</p>
<p>学习项目:</p>
<p><a target="_blank" rel="noopener" href="https://www.xda-developers.com/best-xposed-modules/">2022 最好的Xposed模块: GravityBox, Pixelify, XPrivacyLua</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Lstaynight/xposed-dy">基于Xposed的抖音爬虫，抖音风控后自动一键新机，模拟一个全新的运行环境</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/svengong/xcubebase">基于xposed的frida持久化方案</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/monkeylord/XServer">A Xposed Module for Android Penetration Test, with NanoHttpd.</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/GravityBox/GravityBox">GravityBox</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Xposed-Modules-Repo">Xposed-Modules-Repo</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ferredoxin/QNotified">一个旨在使QQ变得更好用的开源Xposed模块</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/nining377/dolby_beta">杜比大喇叭</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/shatyuka/Zhiliao">知乎去广告Xposed模块</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/yujincheng08/BiliRoaming">哔哩漫游</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Mocha-L/QuJing">曲境</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/monkeylord/XposedTemplateForAS">自动化创建Xposed模块及钩子，让Xposed模块编写时只需关注钩子实现</a></p>
<h3 id="5-Xposed环境配置"><a href="#5-Xposed环境配置" class="headerlink" title="5.Xposed环境配置"></a><strong>5.Xposed环境配置</strong></h3><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a><strong>前置</strong></h3><p>ubuntu虚拟机镜像，感谢沐阳哥提供的镜像！！！</p>
<p>内置:</p>
<ul>
<li><code>Frida</code>开发环境</li>
<li>动态分析及开发工具：android-studio</li>
<li>动态分析工具：ddms</li>
<li>静态分析工具：jadx1.4.4</li>
<li>动静态分析工具：jeb</li>
<li>动态分析工具：集成HyperPwn</li>
<li>静态分析工具：010 editor</li>
<li>抓包工具：Charles</li>
<li>抓包工具：WireShark</li>
<li>动态分析工具:unidbg</li>
</ul>
<p>vm虚拟机：<a target="_blank" rel="noopener" href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p>
<p>(或下载我打包好的)</p>
<p>激活码自行百度哦</p>
<p>第一步，安装虚拟机调整路径，输入激活码</p>
<p>第二步，导入镜像，文件-&gt;打开-&gt;选择解压好的镜像</p>
<p>第三步，点击运行，待初始化，输入密码:toor</p>
<hr>
<p>1.Android Studio创建新项目</p>
<p>2.将下载的xposedBridgeApi.jar包拖进libs文件夹</p>
<p>3.右击jar包，选择add as library</p>
<ul>
<li><p>4.修改xml文件配置</p>
  <figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 是否是xposed模块，xposed根据这个来判断是否是模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">&nbsp; &nbsp; <span class="hljs-attr">android:name</span>=<span class="hljs-string">"xposedmodule"</span></span><br><span class="hljs-tag">&nbsp; &nbsp; <span class="hljs-attr">android:value</span>=<span class="hljs-string">"true"</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 模块描述，显示在xposed模块列表那里第二行 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">&nbsp; &nbsp; <span class="hljs-attr">android:name</span>=<span class="hljs-string">"xposeddescription"</span></span><br><span class="hljs-tag">&nbsp; &nbsp; <span class="hljs-attr">android:value</span>=<span class="hljs-string">"这是一个Xposed模块"</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 最低xposed版本号(lib文件名可知) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">&nbsp; &nbsp; <span class="hljs-attr">android:name</span>=<span class="hljs-string">"xposedminversion"</span></span><br><span class="hljs-tag">&nbsp; &nbsp; <span class="hljs-attr">android:value</span>=<span class="hljs-string">"89"</span> /&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059490.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>5.修改build.gradle,将此处修改为compileOnly 默认的是implementation</p>
  <figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">**<span class="hljs-keyword">implementation</span> 使用该方式依赖的库将会参与编译和打包<br>compileOnly 只在编译时有效，不会参与打包**<br></code></pre></td></tr></tbody></table></figure>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262059812.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>6.新建–&gt;Folder–&gt;Assets Folder，创建xposed_init(不要后缀名):只有一行代码，就是说明入口类</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100155.png" srcset="/img/loading.gif" lazyload></p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100156.png" srcset="/img/loading.gif" lazyload></p>
<p>  这里用来填写我们具体的hook入口，先建一个hook文档。根据新建的Hook文档来声明入口</p>
<p>  <code>com.cc.xoseddemo1.Hook</code></p>
</li>
<li><p>7.新建Hook类，实现IXposedHookLoadPackage接口，然后在handleLoadPackage函数内编写Hook逻辑</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100386.png" srcset="/img/loading.gif" lazyload></p>
<p>  继承了IXposedHookLoadPackag便拥有了hook的能力</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;<br><span class="hljs-keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IXposedHookLoadPackage</span> {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleLoadPackage</span><span class="hljs-params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="hljs-keyword">throws</span> Throwable {<br><br>&nbsp; &nbsp; }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100074.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h2 id="6-Xpoosed常用API"><a href="#6-Xpoosed常用API" class="headerlink" title="6.Xpoosed常用API"></a><strong>6.Xpoosed常用API</strong></h2><p><a target="_blank" rel="noopener" href="https://github.com/fankes/YukiHookAPI">An efficient Hook API and Xposed Module solution built in Kotlin</a></p>
<ul>
<li><p>示例</p>
<ol>
<li>使用logcat对日志进行捕捉过滤</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100371.png" srcset="/img/loading.gif" lazyload></p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262100372.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>找到我们要Hook的普通方法，发现传入了a，我们对a进行Hook</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101405.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>在hook之前需要先做一个判断，如果直接进行打包的话，会Hook手机中的所有应用，我们通过包名进行过滤</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101120.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>将第2步复制的xposed片段复制进去，利用快捷键进行导包，完成Hook该函数方法的基本框架，如下图方法前后的两个回调函数。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101716.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>修改传入的参数值，这里我们可以使用日志输出（可以在lsp软件中的日志里查看）的方式验证一下函数（用XP自带的API）</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262101026.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>语法解析</p>
<h3 id="一、代码逐层解析"><a href="#一、代码逐层解析" class="headerlink" title="一、代码逐层解析"></a>一、代码逐层解析</h3><h3 id="1-XposedBridge-log"><a href="#1-XposedBridge-log" class="headerlink" title="1.&nbsp;XposedBridge.log()"></a>1.&nbsp;<strong><code>XposedBridge.log()</code></strong></h3><ul>
<li><strong>作用</strong>：Xposed框架提供的日志输出接口，将内容写入Xposed Installer的日志系统（可通过Xposed应用查看）。</li>
<li><strong>语法特性</strong>：<ul>
<li><code>XposedBridge</code>&nbsp;是Xposed框架的核心类，提供模块与框架的交互接口。</li>
<li><code>log()</code>&nbsp;是静态方法，可直接调用，无需实例化对象。</li>
<li>参数类型为&nbsp;<code>String</code>，需传递字符串内容。</li>
</ul>
</li>
</ul>
<h3 id="2-param-args"><a href="#2-param-args" class="headerlink" title="2.&nbsp;param.args"></a>2.&nbsp;<strong><code>param.args</code></strong></h3><ul>
<li><p><strong><code>param</code>&nbsp;的来源</strong>：</p>
<ul>
<li><p>来自Xposed Hook回调函数的参数，通常是&nbsp;<code>XC_MethodHook.MethodHookParam</code>&nbsp;对象。</p>
</li>
<li><p>例如在Hook方法时定义的回调：</p>
  <figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">XposedHelpers</span>.<span class="hljs-title function_">findAndHookMethod</span>(<span class="hljs-string">"com.example.TargetClass"</span>,<br>    loadPackageParam.<span class="hljs-property">classLoader</span>,<br>    <span class="hljs-string">"targetMethod"</span>,<br>    <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title function_">XC_MethodHook</span>(<span class="hljs-params"></span>) {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">beforeHookedMethod</span>(<span class="hljs-params"><span class="hljs-title class_">MethodHookParam</span> param</span>) {<br>            <span class="hljs-comment">// 这里的param即MethodHookParam实例</span><br>            <span class="hljs-title class_">XposedBridge</span>.<span class="hljs-title function_">log</span>(param.<span class="hljs-property">args</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>());<br>        }<br>    });<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong><code>args</code>&nbsp;属性</strong>：</p>
<ul>
<li>是被Hook方法的参数列表（<code>Object[]</code>&nbsp;数组）。</li>
<li>例如：若被Hook方法签名是&nbsp;<code>void func(String arg1, int arg2)</code>，则：<ul>
<li><code>param.args[0]</code>&nbsp;对应&nbsp;<code>arg1</code>（类型为String）</li>
<li><code>param.args[1]</code>&nbsp;对应&nbsp;<code>arg2</code>（类型为Integer，自动装箱）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-param-args-0"><a href="#3-param-args-0" class="headerlink" title="3.&nbsp;param.args[0]"></a>3.&nbsp;<strong><code>param.args[0]</code></strong></h3><ul>
<li>表示获取被Hook方法的&nbsp;<strong>第一个参数</strong>。</li>
<li>索引从0开始：<ul>
<li><code>param.args[0]</code>&nbsp;→ 第1个参数</li>
<li><code>param.args[1]</code>&nbsp;→ 第2个参数</li>
<li>依此类推。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>若方法无参数（如&nbsp;<code>void func()</code>），访问&nbsp;<code>args[0]</code>&nbsp;会导致&nbsp;<code>ArrayIndexOutOfBoundsException</code>。</li>
<li>需确保目标方法至少有一个参数。</li>
</ul>
</li>
</ul>
<h3 id="4-toString"><a href="#4-toString" class="headerlink" title="4.&nbsp;.toString()"></a>4.&nbsp;<strong><code>.toString()</code></strong></h3><ul>
<li>将参数对象转换为字符串：<ul>
<li>若参数是Java对象（如String、自定义类实例），调用其&nbsp;<code>toString()</code>&nbsp;方法。</li>
<li>若参数是基本类型（如int、boolean），自动装箱为Integer、Boolean后调用&nbsp;<code>toString()</code>。</li>
</ul>
</li>
<li><strong>风险点</strong>：<ul>
<li><p>若参数为&nbsp;<code>null</code>，调用&nbsp;<code>null.toString()</code>&nbsp;会抛出&nbsp;<code>NullPointerException</code>。</p>
</li>
<li><p>可优化为安全调用：</p>
  <figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">(param.<span class="hljs-property">args</span>[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span> ? param.<span class="hljs-property">args</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>() : <span class="hljs-string">"null"</span>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、完整代码流程"><a href="#二、完整代码流程" class="headerlink" title="二、完整代码流程"></a>二、完整代码流程</h3><ol>
<li><strong>Hook目标方法</strong>：通过Xposed框架注册Hook点，拦截某个类的方法调用。</li>
<li><strong>进入回调函数</strong>：当目标方法被调用时，触发&nbsp;<code>beforeHookedMethod</code>&nbsp;或&nbsp;<code>afterHookedMethod</code>&nbsp;回调。</li>
<li><strong>访问参数</strong>：通过&nbsp;<code>param.args</code>&nbsp;数组获取方法参数值。</li>
<li><strong>转换字符串</strong>：调用&nbsp;<code>toString()</code>&nbsp;将参数转为可读字符串。</li>
<li><strong>记录日志</strong>：通过&nbsp;<code>XposedBridge.log()</code>&nbsp;输出到Xposed日志系统。</li>
</ol>
<hr>
<h3 id="三、典型应用场景"><a href="#三、典型应用场景" class="headerlink" title="三、典型应用场景"></a>三、典型应用场景</h3><h3 id="场景：监控某个应用的登录密码参数"><a href="#场景：监控某个应用的登录密码参数" class="headerlink" title="场景：监控某个应用的登录密码参数"></a>场景：监控某个应用的登录密码参数</h3><p>  假设Hook一个登录方法&nbsp;<code>login(String username, String password)</code>：</p>
<p>  java</p>
<p>  复制</p>
  <figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">XposedBridge.<span class="hljs-built_in">log</span>(<span class="hljs-string">"用户名："</span> + param.<span class="hljs-keyword">args</span>[0].<span class="hljs-keyword">toString</span>());<br>XposedBridge.<span class="hljs-built_in">log</span>(<span class="hljs-string">"密码："</span> + param.<span class="hljs-keyword">args</span>[1].<span class="hljs-keyword">toString</span>());<br></code></pre></td></tr></tbody></table></figure>
<p>  输出结果：</p>
<p>  复制</p>
  <figure class="highlight nsis"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">用户名：<span class="hljs-literal">admin</span><br>密码：<span class="hljs-number">123456</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="防御措施（逆向对抗）："><a href="#防御措施（逆向对抗）：" class="headerlink" title="防御措施（逆向对抗）："></a>防御措施（逆向对抗）：</h3><ul>
<li><strong>参数混淆</strong>：将参数类型从String改为byte数组，增加可读性难度。</li>
<li><strong>主动检测Xposed</strong>：在关键方法中检测Xposed环境，若存在则拒绝执行。</li>
</ul>
</li>
</ul>
<ol>
<li>同样我们也可以用安卓自带的log</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262102101.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>语法解析</p>
<h3 id="1-Log-d-zj2595-param-args-0-toString"><a href="#1-Log-d-zj2595-param-args-0-toString" class="headerlink" title="1.&nbsp;Log.d(&quot;zj2595&quot;, param.args[0.toString());"></a><strong>1.&nbsp;<code>Log.d("zj2595", param.args[0.toString());</code></strong></h3><ul>
<li><strong>作用</strong>：通过Android原生日志系统输出被Hook方法的第一个参数值。</li>
<li><strong>语法</strong>：<ul>
<li><code>Log.d(String tag, String msg)</code>：Android的调试日志接口，<code>tag</code>为日志标签，<code>msg</code>为日志内容。</li>
<li><code>param.args[0]</code>：获取被Hook方法的第一个参数（索引从0开始）。</li>
<li><code>toString()</code>：将参数对象转为字符串（可能因对象类型不同而结果不同）。</li>
</ul>
</li>
<li><strong>风险</strong>：<ul>
<li><p>若参数为&nbsp;<code>null</code>，<code>toString()</code>&nbsp;会抛出&nbsp;<code>NullPointerException</code>。</p>
</li>
<li><p>建议优化为安全调用：</p>
<p>  java</p>
<p>  复制</p>
  <figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">String arg0 = (param.<span class="hljs-keyword">args</span>[0] != null) ? param.<span class="hljs-keyword">args</span>[0].<span class="hljs-keyword">toString</span>() : <span class="hljs-string">"null"</span>;<br><span class="hljs-keyword">Log</span>.<span class="hljs-built_in">d</span>(<span class="hljs-string">"zj2595"</span>, arg0);<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-XposedBridge-log-param-args-0-toString"><a href="#2-XposedBridge-log-param-args-0-toString" class="headerlink" title="2.&nbsp;XposedBridge.log(param.args[0].toString());"></a><strong>2.&nbsp;<code>XposedBridge.log(param.args[0].toString());</code></strong></h3><ul>
<li><strong>作用</strong>：通过Xposed框架的日志系统记录参数值。</li>
<li><strong>特点</strong>：<ul>
<li>日志内容可在Xposed Installer的日志页面查看，独立于Android原生日志。</li>
<li>适合长期调试，但缺乏日志标签分类。</li>
</ul>
</li>
</ul>
<h3 id="3-String-a-pt"><a href="#3-String-a-pt" class="headerlink" title="3.&nbsp;String a = &quot;pt&quot;;"></a><strong>3.&nbsp;<code>String a = "pt";</code></strong></h3><ul>
<li><strong>作用</strong>：定义一个字符串变量&nbsp;<code>a</code>，值为&nbsp;<code>"pt"</code>。</li>
<li><strong>潜在用途</strong>：<ul>
<li>硬编码替换目标参数值（如修改密码、密钥等）。</li>
<li>可作为中间变量防止直接暴露敏感逻辑。</li>
</ul>
</li>
</ul>
<h3 id="4-param-args-0-a"><a href="#4-param-args-0-a" class="headerlink" title="4.&nbsp;param.args[0] = a;"></a><strong>4.&nbsp;<code>param.args[0] = a;</code></strong></h3><ul>
<li><strong>作用</strong>：修改被Hook方法的第一个参数值为&nbsp;<code>"pt"</code>。</li>
<li><strong>原理</strong>：<ul>
<li>Xposed框架的&nbsp;<code>MethodHookParam</code>&nbsp;对象允许在&nbsp;<code>beforeHookedMethod</code>&nbsp;阶段修改参数值。</li>
<li>修改后的值会传递给原始方法执行，从而实现<strong>运行时参数篡改</strong>。</li>
</ul>
</li>
<li><strong>限制</strong>：<ul>
<li>只能在&nbsp;<code>beforeHookedMethod</code>&nbsp;回调中修改参数（<code>afterHookedMethod</code>&nbsp;阶段修改无效）。</li>
<li>参数类型需匹配目标方法声明类型，否则可能引发类型转换异常。</li>
</ul>
</li>
</ul>
<h3 id="5-Log-d-zj2595-param-args-0-toString"><a href="#5-Log-d-zj2595-param-args-0-toString" class="headerlink" title="5.&nbsp;Log.d(&quot;zj2595&quot;, param.args[0].toString());"></a><strong>5.&nbsp;<code>Log.d("zj2595", param.args[0].toString());</code></strong></h3><ul>
<li><strong>作用</strong>：验证参数是否被成功修改。</li>
<li><strong>预期输出</strong>：<ul>
<li>若修改成功，日志应显示&nbsp;<code>pt</code>。</li>
<li>若修改失败，日志仍显示原始值（需检查Hook点是否正确）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a><strong>完整流程</strong></h3><ol>
<li><strong>拦截方法调用</strong>：通过Xposed Hook目标方法，进入&nbsp;<code>beforeHookedMethod</code>&nbsp;回调。</li>
<li><strong>记录原始参数</strong>：通过Android日志和Xposed日志输出原始参数值。</li>
<li><strong>篡改参数值</strong>：将第一个参数替换为硬编码值&nbsp;<code>"pt"</code>。</li>
<li><strong>传递修改后的参数</strong>：Xposed框架将修改后的参数传递给原始方法。</li>
<li><strong>验证篡改结果</strong>：通过第二次日志输出确认修改是否生效。</li>
</ol>
<hr>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a><strong>典型应用场景</strong></h3><h3 id="场景：绕过密码验证"><a href="#场景：绕过密码验证" class="headerlink" title="场景：绕过密码验证"></a><strong>场景：绕过密码验证</strong></h3><p>  假设目标方法为&nbsp;<code>checkPassword(String password)</code>：</p>
<p>  java</p>
<p>  复制</p>
  <figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">checkPassword</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> password</span>) {<br>    <span class="hljs-keyword">return</span> password.<span class="hljs-title function_">equals</span>(<span class="hljs-string">"secret"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>  通过以下代码篡改参数：</p>
<p>  java</p>
<p>  复制</p>
  <figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">param.args[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-string">"secret"</span><span class="hljs-comment">; // 强制让密码验证通过</span><br></code></pre></td></tr></tbody></table></figure>
<p>  此时无论用户输入什么密码，方法都会返回&nbsp;<code>true</code>。</p>
<h3 id="防御措施（逆向对抗）：-1"><a href="#防御措施（逆向对抗）：-1" class="headerlink" title="防御措施（逆向对抗）："></a><strong>防御措施（逆向对抗）</strong>：</h3><ol>
<li><p><strong>参数校验</strong>：在方法内部对参数值进行二次校验。</p>
<p> java</p>
<p> 复制</p>
 <figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> checkPassword(String <span class="hljs-keyword">password</span>) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">password</span> == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">password</span>.length() != <span class="hljs-number">6</span>) {<br>        throw <span class="hljs-built_in">new</span> SecurityException("Invalid password format");<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">password</span>.equals("secret");<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>检测Hook环境</strong>：通过检查调用栈或类加载器，发现Xposed存在时拒绝执行。</p>
</li>
</ol>
</li>
<li><p>log.d和log.e的区别</p>
<p>  在Android开发中，<code>Log.d()</code>&nbsp;和&nbsp;<code>Log.e()</code>&nbsp;是&nbsp;<code>android.util.Log</code>&nbsp;类提供的不同级别的日志输出方法。它们的核心区别在于<strong>日志级别</strong>、<strong>使用场景</strong>和<strong>输出表现</strong>。以下是详细对比：</p>
<hr>
<h3 id="1-日志级别与语义"><a href="#1-日志级别与语义" class="headerlink" title="1. 日志级别与语义"></a><strong>1. 日志级别与语义</strong></h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>级别（Verbosity）</strong></th>
<th><strong>语义含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Log.d(String tag, String msg)</code></td>
<td><strong>DEBUG</strong></td>
<td>输出调试信息，用于开发阶段追踪程序流程、变量值等非关键信息。</td>
</tr>
<tr>
<td><code>Log.e(String tag, String msg)</code></td>
<td><strong>ERROR</strong></td>
<td>输出错误信息，表示发生了严重问题（如崩溃、功能失效等），需要优先处理。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a><strong>2. 使用场景</strong></h3><h3 id="Log-d-（调试日志）"><a href="#Log-d-（调试日志）" class="headerlink" title="Log.d()（调试日志）"></a><strong><code>Log.d()</code>（调试日志）</strong></h3><ul>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>追踪代码执行流程（如方法调用顺序）。</li>
<li>输出临时变量的值（如参数、中间计算结果）。</li>
<li>调试逻辑分支（如条件判断是否进入某个分支）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<p>  java</p>
<p>  复制</p>
  <figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">Log</span>.<span class="hljs-built_in">d</span>(<span class="hljs-string">"MainActivity"</span>, <span class="hljs-string">"onCreate() called"</span>); <span class="hljs-comment">// 跟踪生命周期</span><br><span class="hljs-keyword">Log</span>.<span class="hljs-built_in">d</span>(<span class="hljs-string">"Network"</span>, <span class="hljs-string">"Response data: "</span> + response); <span class="hljs-comment">// 输出网络响应数据</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="Log-e-（错误日志）"><a href="#Log-e-（错误日志）" class="headerlink" title="Log.e()（错误日志）"></a><strong><code>Log.e()</code>（错误日志）</strong></h3><ul>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>记录程序异常（如&nbsp;<code>try-catch</code>&nbsp;块中的错误）。</li>
<li>标记不可恢复的故障（如数据库连接失败、关键API调用错误）。</li>
<li>输出对用户体验有重大影响的错误（如支付失败、数据丢失）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<p>  java</p>
<p>  复制</p>
  <figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">try</span> {<br>    parseJson(rawData);<br>} <span class="hljs-keyword">catch</span> (JSONException e) {<br>    <span class="hljs-built_in">Log</span>.e(<span class="hljs-string">"Parser"</span>, <span class="hljs-string">"JSON解析失败: "</span> + e.getMessage()); <span class="hljs-comment">// 记录致命错误</span><br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h3 id="3-输出表现"><a href="#3-输出表现" class="headerlink" title="3. 输出表现"></a><strong>3. 输出表现</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong><code>Log.d()</code></strong></th>
<th><strong><code>Log.e()</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Logcat显示颜色</strong></td>
<td>默认黑色（或灰色，取决于IDE主题）</td>
<td><strong>红色</strong>（高亮提示，易于快速定位）</td>
</tr>
<tr>
<td><strong>过滤优先级</strong></td>
<td>低</td>
<td>高（<code>ERROR</code>&nbsp;&gt;&nbsp;<code>WARN</code>&nbsp;&gt;&nbsp;<code>INFO</code>&nbsp;&gt;&nbsp;<code>DEBUG</code>&nbsp;&gt;&nbsp;<code>VERBOSE</code>）</td>
</tr>
<tr>
<td><strong>默认可见性</strong></td>
<td>通常在调试版本（Debug Build）启用</td>
<td>始终输出（即使发布版本也可能保留）</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-实际应用建议"><a href="#4-实际应用建议" class="headerlink" title="4. 实际应用建议"></a><strong>4. 实际应用建议</strong></h3><h3 id="何时用-Log-d？"><a href="#何时用-Log-d？" class="headerlink" title="何时用&nbsp;Log.d？"></a><strong>何时用&nbsp;<code>Log.d</code>？</strong></h3><ul>
<li><p>开发阶段临时调试，需在<strong>发布版本中移除</strong>（通过&nbsp;<code>BuildConfig.DEBUG</code>&nbsp;控制）：</p>
  <figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">if</span> (BuildConfig.DEBUG) {<br>    <span class="hljs-keyword">Log</span>.<span class="hljs-built_in">d</span>(<span class="hljs-string">"Tag"</span>, <span class="hljs-string">"调试信息"</span>); <span class="hljs-comment">// 仅调试版本输出</span><br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>输出高频次、非关键信息（如循环内的变量值）。</p>
</li>
</ul>
<h3 id="何时用-Log-e？"><a href="#何时用-Log-e？" class="headerlink" title="何时用&nbsp;Log.e？"></a><strong>何时用&nbsp;<code>Log.e</code>？</strong></h3><ul>
<li>记录<strong>必须修复</strong>的问题（如崩溃、数据错误）。</li>
<li>需要长期监控的严重事件（即使应用已发布）。</li>
</ul>
<hr>
<h3 id="5-逆向工程中的特殊用途"><a href="#5-逆向工程中的特殊用途" class="headerlink" title="5. 逆向工程中的特殊用途"></a><strong>5. 逆向工程中的特殊用途</strong></h3><p>  在Android逆向分析中，日志输出常用于动态调试：</p>
<ul>
<li><p><strong><code>Log.d</code></strong>：用于追踪目标方法的参数传递或流程分支。</p>
  <figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// Hook方法并输出参数</span><br>XposedBridge.<span class="hljs-built_in">log</span>(<span class="hljs-string">"参数1: "</span> + param.<span class="hljs-keyword">args</span>[0]);<br><span class="hljs-keyword">Log</span>.<span class="hljs-built_in">d</span>(<span class="hljs-string">"Hook"</span>, <span class="hljs-string">"参数1: "</span> + param.<span class="hljs-keyword">args</span>[0]); <span class="hljs-comment">// 双保险记录</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong><code>Log.e</code></strong>：标记关键错误（如加密算法失败、反调试检测触发）。</p>
  <figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">if</span> (detectXposed()) { <span class="hljs-comment">// 检测到Xposed环境</span><br>    <span class="hljs-keyword">Log</span>.<span class="hljs-built_in">e</span>(<span class="hljs-string">"Security"</span>, <span class="hljs-string">"Xposed框架已注入！"</span>); <span class="hljs-comment">// 高亮提示风险</span><br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h3 id="6-其他日志方法对比"><a href="#6-其他日志方法对比" class="headerlink" title="6. 其他日志方法对比"></a><strong>6. 其他日志方法对比</strong></h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>级别</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Log.v()</code></td>
<td>VERBOSE</td>
<td>最详细的日志（极少使用）</td>
</tr>
<tr>
<td><code>Log.i()</code></td>
<td>INFO</td>
<td>普通流程信息（如服务启动）</td>
</tr>
<tr>
<td><code>Log.w()</code></td>
<td>WARN</td>
<td>警告（潜在问题，但未导致错误）</td>
</tr>
</tbody></table>
</li>
</ul>
<p>  7.我们修改好后运行程序，并在手机上勾选我们的Demo模块，再进行查看会发现参数已修改</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262103369.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>返回值的Hook，先打印返回值，然后进行修改</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262103041.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>语法分析</p>
<h3 id="代码作用"><a href="#代码作用" class="headerlink" title="代码作用"></a><strong>代码作用</strong></h3><ul>
<li><p><strong><code>Log.d("zj2595", param.getResult().toString())</code></strong>：</p>
<p>  记录被Hook方法的<strong>原始返回值</strong>到Android调试日志（Logcat）。</p>
</li>
<li><p><strong><code>param.setResult("222222")</code></strong>：</p>
<p>  强制修改被Hook方法的<strong>最终返回值</strong>为字符串&nbsp;<code>"222222"</code>。</p>
</li>
</ul>
<hr>
<h3 id="使用场景（逆向工程典型用途）"><a href="#使用场景（逆向工程典型用途）" class="headerlink" title="使用场景（逆向工程典型用途）"></a><strong>使用场景（逆向工程典型用途）</strong></h3><ol>
<li><p><strong>绕过返回值校验</strong>：</p>
<p> 例如，Hook一个验证函数&nbsp;<code>boolean checkLicense()</code>，将其布尔型返回值从&nbsp;<code>false</code>&nbsp;改为&nbsp;<code>true</code>，实现破解授权逻辑。</p>
</li>
<li><p><strong>篡改敏感数据</strong>：</p>
<p> 例如，Hook获取设备ID的方法&nbsp;<code>String getDeviceId()</code>，返回伪造的ID值。</p>
</li>
<li><p><strong>动态调试分析</strong>：</p>
<p> 通过输出原始返回值，观察目标方法的执行结果，辅助静态反编译分析。</p>
</li>
</ol>
<hr>
<h3 id="代码执行原理"><a href="#代码执行原理" class="headerlink" title="代码执行原理"></a><strong>代码执行原理</strong></h3><h3 id="1-依赖的上下文"><a href="#1-依赖的上下文" class="headerlink" title="1. 依赖的上下文"></a><strong>1. 依赖的上下文</strong></h3><ul>
<li><p><strong><code>param</code>&nbsp;的类型</strong>：</p>
<p>  <code>XC_MethodHook.MethodHookParam</code>（Xposed框架的回调参数对象）。</p>
</li>
<li><p><strong>触发阶段</strong>：</p>
<p>  代码需写在&nbsp;<code>afterHookedMethod</code>&nbsp;回调中（若在&nbsp;<code>beforeHookedMethod</code>&nbsp;阶段调用&nbsp;<code>getResult()</code>，返回值可能为&nbsp;<code>null</code>）。</p>
</li>
</ul>
<h3 id="2-关键方法说明"><a href="#2-关键方法说明" class="headerlink" title="2. 关键方法说明"></a><strong>2. 关键方法说明</strong></h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>param.getResult()</code></td>
<td>获取被Hook方法的原始返回值（需在&nbsp;<code>afterHookedMethod</code>&nbsp;阶段调用有效）。</td>
</tr>
<tr>
<td><code>param.setResult()</code></td>
<td>强制修改方法的返回值（可完全覆盖原始逻辑的执行结果）。</td>
</tr>
</tbody></table>
<h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a><strong>3. 执行流程</strong></h3><ol>
<li><strong>拦截目标方法</strong>：通过Xposed Hook目标方法（如&nbsp;<code>getToken()</code>）。</li>
<li><strong>进入回调阶段</strong>：在&nbsp;<code>afterHookedMethod</code>&nbsp;中执行代码。</li>
<li><strong>记录原始返回值</strong>：通过&nbsp;<code>Log.d</code>&nbsp;输出原始值到Logcat。</li>
<li><strong>篡改返回值</strong>：使用&nbsp;<code>setResult</code>&nbsp;覆盖为指定值（如&nbsp;<code>"222222"</code>）。</li>
<li><strong>传递结果</strong>：修改后的值返回给调用者，原始逻辑被绕过。</li>
</ol>
<hr>
<h3 id="完整示例（Xposed模块代码）"><a href="#完整示例（Xposed模块代码）" class="headerlink" title="完整示例（Xposed模块代码）"></a><strong>完整示例（Xposed模块代码）</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.example.TargetClass"</span>,<br>    loadPackageParam.classLoader,<br>    <span class="hljs-string">"getSecretData"</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> {<br>            <span class="hljs-comment">// 1. 记录原始返回值</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">originalResult</span> <span class="hljs-operator">=</span> param.getResult();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">logMsg</span> <span class="hljs-operator">=</span> (originalResult != <span class="hljs-literal">null</span>) ? originalResult.toString() : <span class="hljs-string">"null"</span>;<br>            Log.d(<span class="hljs-string">"zj2595"</span>, <span class="hljs-string">"原始返回值: "</span> + logMsg);<br>            XposedBridge.log(<span class="hljs-string">"原始返回值: "</span> + logMsg);<br><br>            <span class="hljs-comment">// 2. 篡改返回值</span><br>            param.setResult(<span class="hljs-string">"222222"</span>);<br><br>            <span class="hljs-comment">// 3. 验证修改结果</span><br>            Log.d(<span class="hljs-string">"zj2595"</span>, <span class="hljs-string">"修改后返回值: "</span> + param.getResult().toString());<br>        }<br>    });<br></code></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="逆向对抗与防御"><a href="#逆向对抗与防御" class="headerlink" title="逆向对抗与防御"></a><strong>逆向对抗与防御</strong></h3><h3 id="针对返回值篡改的防护"><a href="#针对返回值篡改的防护" class="headerlink" title="针对返回值篡改的防护"></a><strong>针对返回值篡改的防护</strong></h3><ol>
<li><p><strong>签名校验</strong>：</p>
<p> 在关键方法中增加对返回值的二次校验（如哈希校验）：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> fetchFromServer();<br>    <span class="hljs-keyword">if</span> (!verifyHash(data)) { <span class="hljs-comment">// 校验数据完整性</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">"数据被篡改！"</span>);<br>    }<br>    <span class="hljs-keyword">return</span> data;<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>混淆返回值类型</strong>：</p>
<p> 使用复杂对象（非基本类型）作为返回值，增加篡改难度：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ResultBean <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultBean</span>(<span class="hljs-number">200</span>, <span class="hljs-string">"OK"</span>, encryptedData);<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>检测Hook环境</strong>：</p>
<p> 在方法内部检查调用栈或类加载器，识别Xposed注入：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isXposedActive()) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">"检测到Hook框架！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1-Hook普通方法"><a href="#1-Hook普通方法" class="headerlink" title="1.Hook普通方法"></a><strong>1.Hook普通方法</strong></h3><p>修改返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, loadPackageParam.classLoader, <span class="hljs-string">"a"</span>, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;param.setResult(<span class="hljs-number">999</span>);<br>&nbsp; &nbsp; }<br>});<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>语法详解</p>
<ol>
<li><p><strong>XposedHelpers.findAndHookMethod(…)</strong></p>
<p> 这是Xposed框架提供的一个辅助方法，用于在指定类中查找某个方法并对其进行hook（拦截）。</p>
<ul>
<li><strong>目标类</strong>：第一个参数 <code>"com.zj.wuaipojie.Demo"</code> 表示我们希望hook的类。</li>
<li><strong>类加载器</strong>：第二个参数 <code>loadPackageParam.classLoader</code> 指定了加载目标类的类加载器，这样可以确保我们能够正确定位到类文件。</li>
<li><strong>方法名称</strong>：第三个参数 <code>"a"</code> 指明了要hook的方法名。如果该类中有多个同名方法，则后续参数（即参数类型）会帮助确定具体哪一个重载版本。</li>
<li><strong>方法参数</strong>：第四个参数 <code>String.class</code> 表示该方法接收一个类型为String的参数。</li>
<li><strong>回调对象</strong>：最后一个参数是一个 <code>new XC_MethodHook()</code> 实例，里面重写了 <code>afterHookedMethod</code> 方法，这个方法将在原方法执行完毕后被调用。</li>
</ul>
</li>
<li><p><strong>XC_MethodHook 的作用</strong></p>
<p> XC_MethodHook 是Xposed框架提供的一个钩子回调类，它允许你在原方法调用之前（onEnter）或者之后（onLeave/afterHookedMethod）插入自己的代码。</p>
<ul>
<li>此处我们只重写了 <code>afterHookedMethod</code> 方法，意味着在原方法执行完成后，我们会执行我们自己的代码逻辑。</li>
</ul>
</li>
<li><p><strong>afterHookedMethod 方法中的操作</strong></p>
<ul>
<li><p><strong>super.afterHookedMethod(param);</strong></p>
<p>  调用了父类的方法，这通常是为了保持一些内部处理流程。如果不需要特殊逻辑，可以省略这行，但有时保留有助于确保默认行为得以执行。</p>
</li>
<li><p><strong>param.setResult(999);</strong></p>
<p>  这行代码非常关键：它修改了原方法的返回值。无论原方法执行后产生了什么返回值，这里都会将其替换为整数999。</p>
<p>  换句话说，当应用中任何地方调用 <code>com.zj.wuaipojie.Demo</code> 类中名为 <code>a</code> 的方法时（传入一个String参数），即便该方法本身实现了某种逻辑，最终返回的结果都会被hook后改为999。</p>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>目的</strong>：通过Xposed框架拦截目标类中方法的执行，并在方法执行完成后强制修改其返回值。</li>
<li><strong>应用场景</strong>：常用于逆向工程和动态调试，比如绕过某些安全检查或修改应用行为。</li>
<li><strong>关键点</strong>：<ul>
<li>使用 <code>findAndHookMethod</code> 来定位和hook目标方法；</li>
<li>在 <code>afterHookedMethod</code> 回调中使用 <code>param.setResult</code> 修改返回值，从而覆盖原方法的执行结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>修改参数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, loadPackageParam.classLoader, <span class="hljs-string">"a"</span>, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">"pt"</span>;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;param.args[<span class="hljs-number">0</span>] = a;&nbsp; &nbsp; }<br>});<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>语法详解</p>
<ol>
<li><p><strong>XposedHelpers.findAndHookMethod(…)</strong></p>
<p> 这是 Xposed 框架提供的一个便捷方法，用于在指定的类中查找并 hook 某个方法。</p>
<ul>
<li><code>"com.zj.wuaipojie.Demo"</code>：目标类的全限定名，即我们要 hook 的类。</li>
<li><code>loadPackageParam.classLoader</code>：用于加载目标类的类加载器，确保能找到该类。</li>
<li><code>"a"</code>：目标方法的名称，表示要 hook 的方法名是 <code>"a"</code>。</li>
<li><code>String.class</code>：目标方法的参数类型，这里表示方法 <code>"a"</code> 接收一个 <code>String</code> 类型的参数。</li>
<li><code>new XC_MethodHook() { ... }</code>：传入一个匿名内部类，用于定义 hook 后的回调行为。</li>
</ul>
</li>
<li><p><strong>beforeHookedMethod 回调</strong></p>
<p> 这个方法会在目标方法执行之前被调用。其主要作用是允许我们在原方法运行之前修改传入的参数或执行其他操作。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>    <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">"pt"</span>;<br>    param.args[<span class="hljs-number">0</span>] = a;<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><p><strong>super.beforeHookedMethod(param);</strong></p>
<p>  调用父类的方法，通常是为了保持默认行为。这一行在很多场景中可以省略，但有时保留能确保框架内部逻辑正常执行。</p>
</li>
<li><p><strong>String a = “pt”;</strong></p>
<p>  定义了一个字符串变量 <code>a</code>，并赋值为 <code>"pt"</code>。</p>
</li>
<li><p><strong>param.args[0] = a;</strong></p>
<p>  修改了 <code>param.args</code> 数组中索引为 0 的参数值（即传入目标方法的第一个参数）。原来传入方法的 <code>String</code> 参数将被替换为 <code>"pt"</code>。</p>
<p>  换句话说，每当目标类 <code>com.zj.wuaipojie.Demo</code> 中名为 <code>"a"</code> 的方法被调用时，无论调用方传递的参数是什么，都会在方法执行前被强制改为 <code>"pt"</code>。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>修改行为</strong>：这种 hook 技术常用于修改应用逻辑。例如，若目标方法依据传入的字符串参数执行不同操作，改变参数值可以绕过某些检查或改变原有逻辑。</li>
<li><strong>调试与逆向工程</strong>：在分析应用时，通过修改方法参数，可以观察不同参数对方法执行结果的影响，帮助开发者更好地理解程序内部流程。</li>
</ul>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>  这段代码的作用是在目标方法 <code>"a"</code> 被调用之前，将它的第一个参数（String 类型）修改为固定值 <code>"pt"</code>。这种方式允许开发者动态改变应用行为，而无需修改原始代码，是 Xposed 框架在逆向工程和动态调试中的常见用法。</p>
</li>
</ul>
<h3 id="2-Hook复杂-自定义参数"><a href="#2-Hook复杂-自定义参数" class="headerlink" title="2.Hook复杂&amp;自定义参数"></a><strong>2.Hook复杂&amp;自定义参数</strong></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> loadPackageParam.classLoader.loadClass(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>);<br>        XposedBridge.hookAllMethods(a, <span class="hljs-string">"complexParameterFunc"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() { <span class="hljs-comment">//主要用到该方法可以免填参数（针对自定义和复杂方法）</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>                Log.d(<span class="hljs-string">"zj2595"</span>,param.args[<span class="hljs-number">0</span>].toString());<br>            }<br>        });<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>查找Hook复杂函数的类名，方法名</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262103920.png" srcset="/img/loading.gif" lazyload></p>
<p>  2.修改好相应数据后，通过log打印观察</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104375.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>语法解析</p>
<h3 id="1-loadPackageParam-classLoader-loadClass-com-zj-wuaipojie-Demo"><a href="#1-loadPackageParam-classLoader-loadClass-com-zj-wuaipojie-Demo" class="headerlink" title="1. loadPackageParam.classLoader.loadClass(&quot;com.zj.wuaipojie.Demo&quot;)"></a>1. <code>loadPackageParam.classLoader.loadClass("com.zj.wuaipojie.Demo")</code></h3><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li><strong>动态加载</strong> <code>com.zj.wuaipojie.Demo</code> 类。</li>
<li><code>loadPackageParam.classLoader</code> 是 Xposed 提供的 <code>ClassLoader</code>，用于在 Hook 目标 APP 时正确加载目标类。</li>
</ul>
<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><ul>
<li><code>loadPackageParam</code> 是 Xposed <code>handleLoadPackage</code> 方法中的参数，表示当前 Hook 目标应用的上下文信息。</li>
<li><code>loadClass("com.zj.wuaipojie.Demo")</code> 加载 <code>Demo</code> 类，返回一个 <code>Class&lt;?&gt;</code> 对象。</li>
</ul>
<hr>
<h3 id="2-XposedBridge-hookAllMethods-a-complexParameterFunc-new-XC-MethodHook"><a href="#2-XposedBridge-hookAllMethods-a-complexParameterFunc-new-XC-MethodHook" class="headerlink" title="2. XposedBridge.hookAllMethods(a, &quot;complexParameterFunc&quot;, new XC_MethodHook() {...})"></a>2. <code>XposedBridge.hookAllMethods(a, "complexParameterFunc", new XC_MethodHook() {...})</code></h3><h3 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h3><ul>
<li><strong>Hook</strong> <code>a</code> 类中所有名为 <code>complexParameterFunc</code> 的方法，无论其参数类型和返回值是什么。</li>
<li><code>XC_MethodHook</code> 允许我们在方法 <strong>执行前（beforeHookedMethod）或执行后（afterHookedMethod）</strong> 进行操作。</li>
</ul>
<h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><ul>
<li><code>XposedBridge.hookAllMethods(Class&lt;?&gt; hookClass, String methodName, XC_MethodHook callback)</code><ul>
<li><strong><code>hookClass</code></strong>：需要 Hook 的类对象，即 <code>a</code>。</li>
<li><strong><code>methodName</code></strong>：要 Hook 的方法名，此处是 <code>"complexParameterFunc"</code>。</li>
<li><strong><code>callback</code></strong>：一个 <code>XC_MethodHook</code> 实例，包含 <code>beforeHookedMethod</code> 和 <code>afterHookedMethod</code> 两个可重写的方法。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-beforeHookedMethod-MethodHookParam-param-throws-Throwable"><a href="#3-beforeHookedMethod-MethodHookParam-param-throws-Throwable" class="headerlink" title="3. beforeHookedMethod(MethodHookParam param) throws Throwable"></a>3. <code>beforeHookedMethod(MethodHookParam param) throws Throwable</code></h3><h3 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>在 <code>complexParameterFunc</code> <strong>执行之前</strong> 执行 <code>beforeHookedMethod</code> 方法。</li>
<li>可以修改参数、阻止方法执行、获取方法的输入参数等。</li>
</ul>
<h3 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h3><ul>
<li><strong><code>MethodHookParam param</code></strong><ul>
<li>传递给 Hook 方法的 <strong>参数信息</strong>。</li>
<li><code>param.args</code>：存储方法的所有参数，<code>param.args[0]</code> 是第一个参数。</li>
<li><code>param.thisObject</code>：如果 Hook 的是实例方法，这个字段表示该方法所属的对象。</li>
<li><code>param.setResult(Object obj)</code>：直接修改方法返回值，使原方法不执行，返回 <code>obj</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-Log-d-zj2595-param-args-0-toString"><a href="#4-Log-d-zj2595-param-args-0-toString" class="headerlink" title="4. Log.d(&quot;zj2595&quot;, param.args[0].toString());"></a>4. <code>Log.d("zj2595", param.args[0].toString());</code></h3><h3 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>通过 <code>Log.d</code> 打印 <code>complexParameterFunc</code> 方法的 <strong>第一个参数值</strong>，用于调试或分析目标应用的行为。</li>
</ul>
<h3 id="解析：-3"><a href="#解析：-3" class="headerlink" title="解析："></a>解析：</h3><ul>
<li><code>param.args[0]</code>：获取 <code>complexParameterFunc</code> 的第一个参数。</li>
<li><code>.toString()</code>：将参数转换为字符串，避免直接打印对象导致 <code>logcat</code> 显示 <code>null</code> 或 <code>Object@hexcode</code>。</li>
</ul>
<hr>
<h3 id="5-super-beforeHookedMethod-param"><a href="#5-super-beforeHookedMethod-param" class="headerlink" title="5. super.beforeHookedMethod(param);"></a>5. <code>super.beforeHookedMethod(param);</code></h3><h3 id="作用：-4"><a href="#作用：-4" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>调用 <code>XC_MethodHook</code> 的 <code>beforeHookedMethod</code>，通常用于 <strong>保持默认行为</strong>，但在 Xposed 中 <strong>可以省略</strong>，不会影响 Hook 逻辑。</li>
</ul>
<hr>
<h3 id="代码的核心作用"><a href="#代码的核心作用" class="headerlink" title="代码的核心作用"></a><strong>代码的核心作用</strong></h3><ol>
<li><strong>找到</strong> 目标应用 <code>com.zj.wuaipojie.Demo</code> 类。</li>
<li><strong>Hook</strong> 其 <code>complexParameterFunc</code> 方法（可能有多个重载）。</li>
<li><strong>在方法执行前</strong>，打印第一个参数的值，便于分析应用行为或进一步修改参数。</li>
</ol>
<h3 id="关键-Xposed-API"><a href="#关键-Xposed-API" class="headerlink" title="关键 Xposed API"></a><strong>关键 Xposed API</strong></h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>loadClass("com.xxx")</code></td>
<td>通过 <code>ClassLoader</code> 加载类</td>
</tr>
<tr>
<td><code>hookAllMethods(Class, String, XC_MethodHook)</code></td>
<td>Hook 目标类中所有指定名称的方法</td>
</tr>
<tr>
<td><code>beforeHookedMethod(MethodHookParam param)</code></td>
<td>在方法执行前拦截，可修改参数或阻止执行</td>
</tr>
<tr>
<td><code>param.args[n]</code></td>
<td>获取/修改方法参数</td>
</tr>
<tr>
<td><code>param.setResult(Object obj)</code></td>
<td>修改方法返回值并跳过原方法执行</td>
</tr>
</tbody></table>
<h3 id="逆向对抗与加固建议"><a href="#逆向对抗与加固建议" class="headerlink" title="逆向对抗与加固建议"></a><strong>逆向对抗与加固建议</strong></h3><p>  若你是应用开发者，可采取以下措施防止此类Hook：</p>
<ol>
<li><p><strong>代码混淆</strong>：</p>
<p> 混淆方法名和参数名，增加定位难度。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span> { <span class="hljs-comment">// 原始类名 Demo</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(String c)</span> { <span class="hljs-comment">// 原始方法名 complexParameterFunc</span><br>        <span class="hljs-comment">// 业务逻辑</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>参数校验逻辑</strong>：</p>
<p> 在方法内部校验参数合法性。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complexParameterFunc</span><span class="hljs-params">(String input)</span> {<br>    <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span> || input.length() &lt; <span class="hljs-number">8</span>) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"非法参数"</span>);<br>    }<br>    <span class="hljs-comment">// 正常逻辑</span><br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>运行时环境检测</strong>：</p>
<p> 检测Xposed框架存在性。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isXposedActive</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">try</span> {<br>        Class.forName(<span class="hljs-string">"de.robv.android.xposed.XposedBridge"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
<ol>
<li>查看代码发现string是我们打印出来的参数值，同理可以用上述普通方法的Hook进行参数修改</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104386.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h3 id="3-Hook替换函数"><a href="#3-Hook替换函数" class="headerlink" title="3.Hook替换函数"></a><strong>3.Hook替换函数</strong></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> loadPackageParam.classLoader.loadClass(<span class="hljs-string">"类名"</span>);<br>        XposedBridge.hookAllMethods(a,<span class="hljs-string">"方法名"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodReplacement</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam methodHookParam)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>            }<br>        });<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<p>  1.同理得到替换函数的包名，方法名</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104187.png" srcset="/img/loading.gif" lazyload></p>
<p>  2.我们完全替换 目标方法 <code>repleaceFunc</code> 的实现，使其始终返回一个空字符串 </p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262104942.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>语法详解</p>
<h3 id="📌-代码解析"><a href="#📌-代码解析" class="headerlink" title="📌 代码解析"></a><strong>📌 代码解析</strong></h3><h3 id="1-加载目标类"><a href="#1-加载目标类" class="headerlink" title="1. 加载目标类"></a><strong>1. 加载目标类</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> loadPackageParam.classLoader.loadClass(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>);<br></code></pre></td></tr></tbody></table></figure>
<p>  <strong>作用</strong></p>
<ul>
<li>通过 <strong>ClassLoader</strong> 动态加载 <code>com.zj.wuaipojie.Demo</code> 类。</li>
<li><code>loadPackageParam.classLoader</code> 是 Xposed 提供的 ClassLoader，确保能够正确加载 Hook 目标应用中的类。</li>
</ul>
<hr>
<h3 id="2-Hook-目标方法"><a href="#2-Hook-目标方法" class="headerlink" title="2. Hook 目标方法"></a><strong>2. Hook 目标方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedBridge.hookAllMethods(a, <span class="hljs-string">"repleaceFunc"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodReplacement</span>() {...});<br></code></pre></td></tr></tbody></table></figure>
<p>  <strong>作用</strong></p>
<ul>
<li><strong>Hook <code>repleaceFunc</code> 方法的所有重载版本</strong>。</li>
<li>使用 <code>XC_MethodReplacement</code> <strong>完全替换</strong> 目标方法，使其不执行原来的逻辑，而是执行 <code>replaceHookedMethod</code> 方法。</li>
</ul>
<hr>
<h3 id="3-替换方法逻辑"><a href="#3-替换方法逻辑" class="headerlink" title="3. 替换方法逻辑"></a><strong>3. 替换方法逻辑</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam methodHookParam)</span> <span class="hljs-keyword">throws</span> Throwable {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>  <strong>作用</strong></p>
<ul>
<li><code>replaceHookedMethod</code> 直接返回 <code>""</code>（空字符串）。</li>
<li><strong>无论 <code>repleaceFunc</code> 原本的实现是什么，都会被此逻辑取代</strong>。</li>
</ul>
<hr>
<h3 id="🔍-深入解析：Xposed-API"><a href="#🔍-深入解析：Xposed-API" class="headerlink" title="🔍 深入解析：Xposed API"></a><strong>🔍 深入解析：Xposed API</strong></h3><h3 id="🔹-XposedBridge-hookAllMethods-Class-String-XC-MethodReplacement"><a href="#🔹-XposedBridge-hookAllMethods-Class-String-XC-MethodReplacement" class="headerlink" title="🔹 XposedBridge.hookAllMethods(Class, String, XC_MethodReplacement)"></a><strong>🔹 <code>XposedBridge.hookAllMethods(Class, String, XC_MethodReplacement)</code></strong></h3><ul>
<li><strong>作用</strong>：Hook <strong>所有</strong> 名为 <code>repleaceFunc</code> 的方法（包括不同参数的重载）。</li>
<li><strong>区别</strong>：<ul>
<li><code>XC_MethodHook</code> <strong>不会改变原始方法的执行逻辑</strong>，只能在 <strong>执行前/后</strong> 进行拦截。</li>
<li><code>XC_MethodReplacement</code> <strong>完全替换原始方法</strong>，使其不再执行原有代码，而是执行 <code>replaceHookedMethod</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🔹-replaceHookedMethod-MethodHookParam-param"><a href="#🔹-replaceHookedMethod-MethodHookParam-param" class="headerlink" title="🔹 replaceHookedMethod(MethodHookParam param)"></a><strong>🔹 <code>replaceHookedMethod(MethodHookParam param)</code></strong></h3><ul>
<li><strong>作用</strong>：完全取代目标方法的实现逻辑。</li>
<li><strong>返回值</strong>：直接作为方法的返回值，原方法 <strong>不会执行</strong>。</li>
</ul>
<p>  <strong>示例</strong></p>
<p>  假设 <code>repleaceFunc</code> 方法在 <code>Demo</code> 类中的原始代码如下：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">repleaceFunc</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, World!"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>  在 Hook 之后，该方法会始终返回 <code>""</code>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Demo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>System.out.println(demo.repleaceFunc());  <span class="hljs-comment">// 输出：""</span><br></code></pre></td></tr></tbody></table></figure>
<p>  即使 <code>repleaceFunc</code> 之前可能包含复杂逻辑，例如访问数据库、进行计算、返回动态内容，它们都会被 <strong>完全跳过</strong>。</p>
<hr>
<h3 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h3><table>
<thead>
<tr>
<th>代码部分</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>loadPackageParam.classLoader.loadClass("com.zj.wuaipojie.Demo")</code></td>
<td>加载目标类</td>
</tr>
<tr>
<td><code>XposedBridge.hookAllMethods(Class, String, XC_MethodReplacement)</code></td>
<td>Hook 目标方法并完全替换</td>
</tr>
<tr>
<td><code>replaceHookedMethod(MethodHookParam param)</code></td>
<td>定义新的方法逻辑，<strong>不执行原方法</strong></td>
</tr>
<tr>
<td><code>return ""</code></td>
<td>让方法始终返回 <code>""</code></td>
</tr>
</tbody></table>
<h3 id="🔥-适用场景"><a href="#🔥-适用场景" class="headerlink" title="🔥 适用场景"></a><strong>🔥 适用场景</strong></h3><p>  ✅ <strong>修改返回值</strong>（例如：让某个方法始终返回 <code>true/false</code>、0 或者空字符串）</p>
<p>  ✅ <strong>跳过某些功能</strong>（例如：阻止服务器请求、去除广告、绕过校验）</p>
<p>  ✅ <strong>提高性能</strong>（如果方法执行的是不必要的复杂逻辑，可以直接返回固定值）</p>
<hr>
<h1 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a><strong>⚠️ 注意事项</strong></h1><ol>
<li><p><strong>确保目标方法返回类型匹配</strong></p>
<ul>
<li><p><code>return ""</code> 适用于 <strong>返回 <code>String</code> 类型</strong> 的方法。</p>
</li>
<li><p>如果方法返回 <code>int</code>，需要返回 <code>0</code>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果返回 <code>boolean</code>，需要返回 <code>true</code> 或 <code>false</code>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><strong>避免 Hook 关键系统方法</strong></p>
<ul>
<li>Hook 关键 API（如 <code>System.exit()</code>、<code>Application.onCreate()</code>）可能导致 APP <strong>崩溃</strong>。</li>
</ul>
</li>
<li><p><strong>确保 <code>repleaceFunc</code> 方法存在</strong></p>
<ul>
<li>如果 <code>Demo</code> 类中没有 <code>repleaceFunc</code>，Hook <strong>不会生效</strong>，可能导致日志报错。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🚀-实战案例"><a href="#🚀-实战案例" class="headerlink" title="🚀 实战案例"></a><strong>🚀 实战案例</strong></h3><h3 id="1️⃣-绕过应用-VIP-限制"><a href="#1️⃣-绕过应用-VIP-限制" class="headerlink" title="1️⃣ 绕过应用 VIP 限制"></a><strong>1️⃣ 绕过应用 VIP 限制</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedBridge.hookAllMethods(a, <span class="hljs-string">"isVipUser"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodReplacement</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam methodHookParam)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 强制返回 true，让所有用户变成 VIP</span><br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>
<h3 id="2️⃣-禁止-APP-退出"><a href="#2️⃣-禁止-APP-退出" class="headerlink" title="2️⃣ 禁止 APP 退出"></a><strong>2️⃣ 禁止 APP 退出</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedBridge.hookAllMethods(System.class, <span class="hljs-string">"exit"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodReplacement</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam methodHookParam)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 直接跳过 System.exit()，防止 APP 退出</span><br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>
<h3 id="逆向对抗与防护"><a href="#逆向对抗与防护" class="headerlink" title="逆向对抗与防护"></a><strong>逆向对抗与防护</strong></h3><p>  若你是应用开发者，可采取以下防护措施：</p>
<ol>
<li><p><strong>方法签名混淆</strong></p>
<p> 混淆方法名和参数类型，增加定位难度：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span> { <span class="hljs-comment">// 原类名 Demo</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">b</span><span class="hljs-params">()</span> { <span class="hljs-comment">// 原方法名 replaceFunc</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"敏感数据"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>返回值校验</strong></p>
<p> 在调用处增加二次校验逻辑：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> replaceFunc();<br><span class="hljs-keyword">if</span> (result.hashCode() != <span class="hljs-number">0x12345678</span>) { <span class="hljs-comment">// 校验哈希值</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">"返回值被篡改"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>Native层实现</strong></p>
<p> 将核心逻辑移至Native层（C/C++），降低被Xposed Hook的概率：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">replaceFunc</span><span class="hljs-params">()</span>; <span class="hljs-comment">// JNI 实现</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>环境检测</strong></p>
<p> 检测Xposed框架存在性：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHooked</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">try</span> {<br>        <span class="hljs-keyword">return</span> XposedBridge.getXposedVersion() != <span class="hljs-literal">null</span>;<br>    } <span class="hljs-keyword">catch</span> (Throwable ignored) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="4-Hook加固通杀"><a href="#4-Hook加固通杀" class="headerlink" title="4.Hook加固通杀"></a><strong>4.Hook加固通杀</strong></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">"attach"</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (Context) param.args[<span class="hljs-number">0</span>];<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> context.getClassLoader();<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//hook逻辑在这里面写</span><br>&nbsp; &nbsp; }<br>});<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>Hook <code>Application.attach()</code> 方法，并在 <code>attach</code> 执行完成后执行自定义的 Hook 逻辑。它通常用于 在目标应用的 <code>attach</code> 阶段获取 <code>Context</code> 和 <code>ClassLoader</code>，以便 Hook 目标应用的类。必须要将<code>classLoader</code> 传入进去才能通过<code>Application</code>获取<code>classLoader</code>。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262105799.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码详解</p>
<h3 id="📌-代码解析-1"><a href="#📌-代码解析-1" class="headerlink" title="📌 代码解析"></a><strong>📌 代码解析</strong></h3><h3 id="1️⃣-Hook-Application-attach-方法"><a href="#1️⃣-Hook-Application-attach-方法" class="headerlink" title="1️⃣ Hook Application.attach() 方法"></a><strong>1️⃣ Hook <code>Application.attach()</code> 方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">"attach"</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {...});<br></code></pre></td></tr></tbody></table></figure>
<p>  <strong>作用</strong>：</p>
<ul>
<li><code>findAndHookMethod()</code> 用于 <strong>精准 Hook 指定类的特定方法</strong>。</li>
<li>这里 Hook 的是 <code>android.app.Application</code> 类的 <code>attach(Context context)</code> 方法。</li>
<li>由于 <code>attach()</code> 在应用启动时调用，因此 <strong>可以在这里获取 <code>Context</code> 和 <code>ClassLoader</code>，以便 Hook 目标应用的类</strong>。</li>
</ul>
<p>  <strong>为什么要 Hook <code>attach(Context context)</code>？</strong></p>
<ul>
<li>许多应用会使用 <strong>自定义的 <code>ClassLoader</code></strong>，如果在 <code>handleLoadPackage()</code> 里直接 Hook 某些类，可能会找不到（因为类还没加载）。</li>
<li><code>attach()</code> 方法执行时，应用的 <code>Context</code> 和 <code>ClassLoader</code> 已经初始化，Hook 逻辑可以安全执行。</li>
</ul>
<hr>
<h3 id="2️⃣-afterHookedMethod-方法"><a href="#2️⃣-afterHookedMethod-方法" class="headerlink" title="2️⃣ afterHookedMethod() 方法"></a><strong>2️⃣ <code>afterHookedMethod()</code> 方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (Context) param.args[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> context.getClassLoader();<br>    <span class="hljs-comment">//hook逻辑在这里面写</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>  <strong>解析</strong>：</p>
<ul>
<li><code>afterHookedMethod()</code> 代表 <strong>在原方法执行完毕后</strong> 执行 Hook 逻辑。</li>
<li><code>param.args[0]</code> 获取 <code>attach()</code> 方法的 <code>Context</code> 参数，这个 <code>Context</code> 是 <strong>应用的 <code>Context</code></strong>，用于加载资源、访问系统服务等。</li>
<li><code>context.getClassLoader()</code> 获取当前应用的 <code>ClassLoader</code>，用于后续 <strong>动态加载和 Hook 目标类</strong>。</li>
</ul>
<hr>
<h3 id="📌-代码执行流程"><a href="#📌-代码执行流程" class="headerlink" title="📌 代码执行流程"></a><strong>📌 代码执行流程</strong></h3><p>  1️⃣ <code>Application.attach()</code> 被系统调用。</p>
<p>  2️⃣ Xposed Hook 该方法，在 <strong>方法执行完毕后</strong> 获取 <code>Context</code> 和 <code>ClassLoader</code>。</p>
<p>  3️⃣ 在 <code>afterHookedMethod()</code> 里执行 Hook 逻辑，比如 Hook 目标类的方法。</p>
<hr>
<h3 id="🔥-适用场景-1"><a href="#🔥-适用场景-1" class="headerlink" title="🔥 适用场景"></a><strong>🔥 适用场景</strong></h3><p>  ✅ <strong>Hook 目标应用的类</strong></p>
<p>  ✅ <strong>绕过 <code>loadClass</code> 限制</strong>（有些应用使用自定义 <code>ClassLoader</code>，如果不 Hook <code>attach()</code> 可能无法正确加载类）</p>
<p>  ✅ <strong>动态分析应用行为</strong>（例如 Hook <code>WebView</code>、拦截网络请求等）</p>
<p>  ✅ <strong>逆向破解</strong>（比如 Hook 登录验证逻辑、修改返回值等）</p>
<hr>
<h3 id="🚀-进阶应用示例"><a href="#🚀-进阶应用示例" class="headerlink" title="🚀 进阶应用示例"></a><strong>🚀 进阶应用示例</strong></h3><h3 id="1️⃣-Hook-目标应用的方法"><a href="#1️⃣-Hook-目标应用的方法" class="headerlink" title="1️⃣ Hook 目标应用的方法"></a><strong>1️⃣ Hook 目标应用的方法</strong></h3><p>  假设要 Hook <code>com.zj.wuaipojie.Demo</code> 类的 <code>getData()</code> 方法，我们可以在 <code>attach()</code> 里执行 Hook 逻辑：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">"attach"</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (Context) param.args[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> context.getClassLoader();<br><br>        XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, classLoader, <span class="hljs-string">"getData"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                XposedBridge.log(<span class="hljs-string">"Hooked getData() before execution"</span>);<br>            }<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                XposedBridge.log(<span class="hljs-string">"Original return value: "</span> + param.getResult());<br>                param.setResult(<span class="hljs-string">"Hooked Data!"</span>); <span class="hljs-comment">// 修改返回值</span><br>            }<br>        });<br>    }<br>});<br><br></code></pre></td></tr></tbody></table></figure>
<p>  📌 <strong>作用</strong>：Hook <code>com.zj.wuaipojie.Demo.getData()</code>，并修改返回值。</p>
<hr>
<h3 id="2️⃣-Hook-WebView-进行-JS-注入"><a href="#2️⃣-Hook-WebView-进行-JS-注入" class="headerlink" title="2️⃣ Hook WebView 进行 JS 注入"></a><strong>2️⃣ Hook WebView 进行 JS 注入</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">osedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">"attach"</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (Context) param.args[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> context.getClassLoader();<br><br>        XposedHelpers.findAndHookMethod(<span class="hljs-string">"android.webkit.WebView"</span>, classLoader, <span class="hljs-string">"loadUrl"</span>, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> (String) param.args[<span class="hljs-number">0</span>];<br>                XposedBridge.log(<span class="hljs-string">"WebView is loading: "</span> + url);<br>            }<br>        });<br>    }<br>});<br><br></code></pre></td></tr></tbody></table></figure>
<p>  📌 <strong>作用</strong>：Hook <code>WebView.loadUrl()</code> 方法，打印所有加载的 URL。</p>
<hr>
<h3 id="⚠️-注意事项-1"><a href="#⚠️-注意事项-1" class="headerlink" title="⚠️ 注意事项"></a><strong>⚠️ 注意事项</strong></h3><p>  1️⃣ <strong>不能直接在 <code>handleLoadPackage()</code> 里 Hook 目标应用的类</strong></p>
<ul>
<li>有些应用使用 <strong>自定义 ClassLoader</strong>，导致 <code>handleLoadPackage()</code> 时目标类还未加载。</li>
<li>解决方案就是 <strong>先 Hook <code>Application.attach()</code>，等 <code>ClassLoader</code> 初始化后再 Hook 目标方法</strong>。</li>
</ul>
<p>  2️⃣ <strong><code>beforeHookedMethod()</code> vs <code>afterHookedMethod()</code></strong></p>
<ul>
<li><code>beforeHookedMethod()</code>：在方法 <strong>执行前</strong> Hook，可修改参数或阻止执行。</li>
<li><code>afterHookedMethod()</code>：在方法 <strong>执行后</strong> Hook，可获取原始返回值并修改。</li>
</ul>
<p>  3️⃣ <strong>适用于所有 Android 应用</strong></p>
<ul>
<li><code>Application.attach(Context)</code> 是 <strong>所有 Android 应用都会调用的方法</strong>，所以这个 Hook 方式适用于 <strong>所有 APP</strong>，无论它是否混淆或有复杂的 <code>ClassLoader</code> 机制。</li>
</ul>
<hr>
<h3 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a><strong>💡 总结</strong></h3><table>
<thead>
<tr>
<th><strong>代码部分</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>findAndHookMethod(Application.class, "attach", Context.class, XC_MethodHook)</code></td>
<td>Hook <code>attach(Context)</code>，在应用初始化时执行 Hook</td>
</tr>
<tr>
<td><code>context.getClassLoader()</code></td>
<td>获取 <code>ClassLoader</code>，用于加载目标类</td>
</tr>
<tr>
<td><code>findAndHookMethod("目标类", classLoader, "方法名", XC_MethodHook)</code></td>
<td>Hook 目标类的方法</td>
</tr>
<tr>
<td><code>param.args[n]</code></td>
<td>获取或修改方法参数</td>
</tr>
<tr>
<td><code>param.setResult(value)</code></td>
<td>修改返回值</td>
</tr>
<tr>
<td><code>beforeHookedMethod()</code></td>
<td>方法执行前 Hook，可修改参数或阻止执行</td>
</tr>
<tr>
<td><code>afterHookedMethod()</code></td>
<td>方法执行后 Hook，可获取或修改返回值</td>
</tr>
</tbody></table>
<p>  ✅ <strong>这段代码的核心思想是先 Hook <code>Application.attach()</code>，确保 <code>ClassLoader</code> 初始化后，再去 Hook 目标应用的其他方法。</strong></p>
<p>  ✅ <strong>适用于所有 Android 应用，尤其是带有自定义 <code>ClassLoader</code> 的应用。</strong></p>
<h3 id="逆向对抗与加固"><a href="#逆向对抗与加固" class="headerlink" title="逆向对抗与加固"></a><strong>逆向对抗与加固</strong></h3><p>  若你是应用开发者，可采取以下防护措施：</p>
<ol>
<li><p><strong>检测Application.attach是否被Hook</strong></p>
<p> 在<code>attach()</code>方法内检查调用栈：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Context context)</span> {<br>    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();<br>    <span class="hljs-keyword">for</span> (StackTraceElement element : stackTrace) {<br>        <span class="hljs-keyword">if</span> (element.getClassName().contains(<span class="hljs-string">"xposed"</span>)) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">"Xposed框架注入！"</span>);<br>        }<br>    }<br>    <span class="hljs-built_in">super</span>.attach(context);<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>混淆关键类名和方法名</strong></p>
<p> 增加定位难度：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span> { <span class="hljs-comment">// 原类名Application</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(Context c)</span> { <span class="hljs-comment">// 原方法名attach</span><br>        <span class="hljs-comment">// 原始逻辑</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用自定义ClassLoader</strong></p>
<p> 防止通过系统ClassLoader获取类：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> {<br>    <span class="hljs-comment">// 重写loadClass方法，防止外部Hook</span><br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="5-Hook变量"><a href="#5-Hook变量" class="headerlink" title="5.Hook变量"></a><strong>5.Hook变量</strong></h3><p>静态变量与实例变量：</p>
<ul>
<li>静态变量（static）：类被初始化，同步进行初始化</li>
<li>非静态变量：类被实例化（产生一个对象的时候），进行初始化</li>
</ul>
<p>静态变量</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"类名"</span>, classLoader);<br>XposedHelpers.setStaticIntField(clazz, <span class="hljs-string">"变量名"</span>, <span class="hljs-number">999</span>);<br></code></pre></td></tr></tbody></table></figure>

<p>实例变量</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"类名"</span>, classLoader);<br>XposedBridge.hookAllConstructors(clazz, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>        <span class="hljs-comment">//param.thisObject获取当前所属的对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">ob</span> <span class="hljs-operator">=</span> param.thisObject;<br>        XposedHelpers.setIntField(ob,<span class="hljs-string">"变量名"</span>,<span class="hljs-number">9999</span>);}<br>    });<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>Hook静态变量，先根据原码找到我们需要的包名，方法名等信息</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106768.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>根据</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106329.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码解析</p>
<h3 id="代码作用-1"><a href="#代码作用-1" class="headerlink" title="代码作用"></a><strong>代码作用</strong></h3><p>  这两行代码通过Xposed框架<strong>修改目标类的静态整型字段值</strong>，常用于动态篡改应用的配置、状态标志或绕过限制（如试用次数、权限校验等）。</p>
<hr>
<h3 id="逐行分析"><a href="#逐行分析" class="headerlink" title="逐行分析"></a><strong>逐行分析</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 加载目标类</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"类名"</span>, classLoader);<br><br><span class="hljs-comment">// 2. 修改静态整型字段值</span><br>XposedHelpers.setStaticIntField(clazz, <span class="hljs-string">"变量名"</span>, <span class="hljs-number">999</span>);<br></code></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a><strong>关键点解析</strong></h3><h3 id="1-XposedHelpers-findClass"><a href="#1-XposedHelpers-findClass" class="headerlink" title="1.&nbsp;XposedHelpers.findClass()"></a><strong>1.&nbsp;<code>XposedHelpers.findClass()</code></strong></h3><ul>
<li><strong>功能</strong>：通过类加载器查找目标类。</li>
<li><strong>参数</strong>：<ul>
<li><code>"类名"</code>：目标类的全限定名（如&nbsp;<code>com.example.Config</code>）。</li>
<li><code>classLoader</code>：应用的ClassLoader（通常从&nbsp;<code>loadPackageParam</code>&nbsp;或&nbsp;<code>Context</code>&nbsp;获取）。</li>
</ul>
</li>
<li><strong>风险</strong>：若类不存在，抛出&nbsp;<code>ClassNotFoundException</code>。</li>
</ul>
<h3 id="2-XposedHelpers-setStaticIntField"><a href="#2-XposedHelpers-setStaticIntField" class="headerlink" title="2.&nbsp;XposedHelpers.setStaticIntField()"></a><strong>2.&nbsp;<code>XposedHelpers.setStaticIntField()</code></strong></h3><ul>
<li><strong>功能</strong>：强制修改目标类的&nbsp;<strong>静态int字段</strong>。</li>
<li><strong>参数</strong>：<ul>
<li><code>clazz</code>：目标类的Class对象。</li>
<li><code>"变量名"</code>：静态字段名称。</li>
<li><code>999</code>：新值。</li>
</ul>
</li>
<li><strong>限制</strong>：<ul>
<li>字段必须存在且类型为&nbsp;<code>int</code>（非&nbsp;<code>Integer</code>）。</li>
<li>字段访问权限不限（Xposed可绕过&nbsp;<code>private</code>&nbsp;限制）。</li>
</ul>
</li>
</ul>
<h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a><strong>扩展操作</strong></h3><h3 id="1-修改非int字段"><a href="#1-修改非int字段" class="headerlink" title="1. 修改非int字段"></a><strong>1. 修改非int字段</strong></h3><ul>
<li><p><strong>字符串字段</strong>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.setStaticObjectField(clazz, <span class="hljs-string">"API_KEY"</span>, <span class="hljs-string">"hacked_key"</span>);<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>布尔字段</strong>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.setStaticBooleanField(clazz, <span class="hljs-string">"isVIP"</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="2-动态监听字段变化"><a href="#2-动态监听字段变化" class="headerlink" title="2. 动态监听字段变化"></a><strong>2. 动态监听字段变化</strong></h3><p>  结合Hook和反射，在字段被访问时触发逻辑：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(clazz, <span class="hljs-string">"checkLicense"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> {<br>        <span class="hljs-comment">// 每次调用checkLicense前重置试用次数</span><br>        XposedHelpers.setStaticIntField(clazz, <span class="hljs-string">"TRIAL_COUNT"</span>, <span class="hljs-number">999</span>);<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>
<h3 id="防御措施（逆向对抗）：-2"><a href="#防御措施（逆向对抗）：-2" class="headerlink" title="防御措施（逆向对抗）："></a><strong>防御措施（逆向对抗）</strong>：</h3><ol>
<li><p><strong>字段混淆</strong>：</p>
<p> 将字段名改为无意义字符串（如&nbsp;<code>a</code>）：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>值校验逻辑</strong>：</p>
<p> 在代码关键位置校验字段哈希值：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (TRIAL_COUNT != calculateHash()) {<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">"数据篡改！"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>迁移到Native层</strong>：</p>
<p> 使用JNI将关键字段存储在C++层：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTrialCount</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ul>
<ol>
<li>Hook实例变量</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106121.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>Hook所有的构造函数，我们发现静态变量与动态变量Hook完成。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262106592.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码解析</p>
<h3 id="代码作用-2"><a href="#代码作用-2" class="headerlink" title="代码作用"></a><strong>代码作用</strong></h3><p>  该代码通过Hook目标类的<strong>所有构造函数</strong>，在对象实例化完成后，修改其&nbsp;<code>publicInt</code>&nbsp;字段的值为&nbsp;<code>2222</code>。常用于<strong>篡改对象初始化状态</strong>，如绕过校验、强制启用隐藏功能等。</p>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><p>  <strong>1.&nbsp;<code>XposedBridge.hookAllConstructors(clazz, new XC_MethodHook())</code></strong></p>
<ul>
<li><strong><code>XposedBridge.hookAllConstructors</code></strong>：<ul>
<li>这是 Xposed 框架提供的一个方法，用于钩挂指定类的所有构造函数。</li>
<li>参数：<ul>
<li><code>clazz</code>：要钩挂的类。</li>
<li><code>new XC_MethodHook()</code>：创建一个 <code>XC_MethodHook</code> 的匿名类实例，用于定义钩挂逻辑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  <strong>2.&nbsp;<code>@Override protected void afterHookedMethod(MethodHookParam param) throws Throwable</code></strong></p>
<ul>
<li><strong><code>afterHookedMethod</code></strong>：<ul>
<li>这是 <code>XC_MethodHook</code> 类中的一个方法，用于在目标方法（这里是构造函数）执行之后执行自定义逻辑。</li>
<li>参数：<ul>
<li><code>param</code>：<code>MethodHookParam</code> 类型，包含钩挂方法的相关信息，如当前对象实例、方法参数、方法返回值等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  <strong>3.&nbsp;<code>super.afterHookedMethod(param);</code></strong></p>
<ul>
<li>这一行调用了父类的 <code>afterHookedMethod</code> 方法，虽然是可选的，但保持代码完整性。</li>
<li>父类的实现是空的，所以这行代码可以省略。</li>
</ul>
<p>  <strong>4.&nbsp;<code>Object ob = param.thisObject;</code></strong></p>
<ul>
<li><strong><code>param.thisObject</code></strong>：<ul>
<li>获取当前构造函数所创建的对象实例。</li>
<li>在构造函数中，<code>thisObject</code> 指向正在被构造的对象。</li>
</ul>
</li>
</ul>
<p>  <strong>5.&nbsp;<code>XposedHelpers.setIntField(ob, "publicInt", 2222);</code></strong></p>
<ul>
<li><strong><code>XposedHelpers.setIntField</code></strong>：<ul>
<li>这是 Xposed 框架提供的一个工具方法，用于设置对象的字段值。</li>
<li>参数：<ul>
<li><code>ob</code>：目标对象实例。</li>
<li><code>"publicInt"</code>：字段名。</li>
<li><code>2222</code>：要设置的值。</li>
</ul>
</li>
<li>这行代码的作用是将目标对象的 <code>publicInt</code> 字段值修改为 <code>2222</code>。</li>
</ul>
</li>
</ul>
<h3 id="逆向对抗与加固-1"><a href="#逆向对抗与加固-1" class="headerlink" title="逆向对抗与加固"></a><strong>逆向对抗与加固</strong></h3><p>  若你是应用开发者，可采取以下防护措施：</p>
<ol>
<li><p><strong>字段混淆</strong>：</p>
<p> 将关键字段名改为无意义字符串（如&nbsp;<code>a</code>）：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 原字段名 publicInt</span><br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>字段值校验</strong>：</p>
<p> 在关键方法中校验字段哈希值：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validate</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">if</span> (publicInt != calculateHash()) {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">"字段被篡改！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>构造函数逻辑保护</strong>：</p>
<p> 在构造后二次加密字段值：</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureClass</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> publicInt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SecureClass</span><span class="hljs-params">()</span> {<br>        publicInt = <span class="hljs-number">100</span>;<br>        publicInt = encrypt(publicInt); <span class="hljs-comment">// 构造函数内二次处理</span><br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">return</span> value ^ <span class="hljs-number">0x12345678</span>; <span class="hljs-comment">// 简单加密</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
<hr>
<h3 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a><strong>扩展操作</strong></h3><h3 id="1-条件篡改"><a href="#1-条件篡改" class="headerlink" title="1. 条件篡改"></a><strong>1. 条件篡改</strong></h3><p>  仅在满足条件时修改字段值：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (XposedHelpers.getIntField(instance, <span class="hljs-string">"publicInt"</span>) &lt; <span class="hljs-number">1000</span>) {<br>    XposedHelpers.setIntField(instance, <span class="hljs-string">"publicInt"</span>, <span class="hljs-number">2222</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="2-多字段操作"><a href="#2-多字段操作" class="headerlink" title="2. 多字段操作"></a><strong>2. 多字段操作</strong></h3><p>  同时修改多个字段：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.setIntField(instance, <span class="hljs-string">"publicInt"</span>, <span class="hljs-number">2222</span>);<br>XposedHelpers.setObjectField(instance, <span class="hljs-string">"mode"</span>, <span class="hljs-string">"DEBUG"</span>);<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="6-Hook构造函数"><a href="#6-Hook构造函数" class="headerlink" title="6.Hook构造函数"></a><strong>6.Hook构造函数</strong></h3><p>无参构造函数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookConstructor(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, classLoader, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>&nbsp; &nbsp; }<br>});<br></code></pre></td></tr></tbody></table></figure>

<p>有参构造函数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">posedHelpers.findAndHookConstructor(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, classLoader, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>            }<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>            }<br>        });<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<p>  1.Hook有参构造函数，查看源代码，发现传入的是str字符串</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107135.png" srcset="/img/loading.gif" lazyload></p>
<p>  2.我们Hook传入的str参数进行修改</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107894.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码详解</p>
<h3 id="1-XposedHelpers-findAndHookConstructor"><a href="#1-XposedHelpers-findAndHookConstructor" class="headerlink" title="1. XposedHelpers.findAndHookConstructor"></a><strong>1. XposedHelpers.findAndHookConstructor</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">XosedHelpers.findAndHookConstructor(String className, ClassLoader classLoader, Object... parameterTypesAndCallback)<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="findAndHookConstructor方法"><a href="#findAndHookConstructor方法" class="headerlink" title="findAndHookConstructor方法"></a><strong><code>findAndHookConstructor</code>方法</strong></h3><ul>
<li><strong>功能</strong>：查找并Hook指定类的构造函数。</li>
<li><strong>参数解析</strong>：<ul>
<li><code>"com.zj.wuaipojie.Demo"</code>：目标类的全限定名。</li>
<li><code>loadPackageParam.classLoader</code>：使用目标应用的类加载器，确保正确加载类（避免ClassNotFound）。</li>
<li><code>String.class</code>：构造函数的参数类型（需与实际参数类型严格匹配）。</li>
<li><code>XC_MethodHook</code>：Hook行为的回调实现。</li>
</ul>
</li>
</ul>
<h3 id="XC-MethodHook回调"><a href="#XC-MethodHook回调" class="headerlink" title="XC_MethodHook回调"></a><strong><code>XC_MethodHook</code>回调</strong></h3><ul>
<li><p><strong><code>beforeHookedMethod</code></strong>：</p>
<ul>
<li><strong>执行时机</strong>：目标方法（构造函数）执行前。</li>
<li><strong>操作</strong>：通过<code>param.args</code>修改传入参数（此处将第一个参数替换为<code>"CC"</code>）。</li>
</ul>
</li>
<li><p><strong><code>afterHookedMethod</code></strong>：</p>
<ul>
<li><strong>执行时机</strong>：目标方法执行后。</li>
<li><strong>操作</strong>：可访问返回值（<code>param.getResult()</code>）或异常（<code>param.getThrowable()</code>）。</li>
</ul>
</li>
<li><p><code>className</code>: 要 Hook 的类名（这里是 <code>"com.zj.wuaipojie.Demo"</code>）。</p>
</li>
<li><p><code>classLoader</code>: 目标应用的类加载器（这里 <code>loadPackageParam.classLoader</code> 提供了 <code>APK</code> 的 <code>ClassLoader</code>）。</p>
</li>
<li><p><code>parameterTypesAndCallback</code>: 先列出构造函数的参数类型（这里是 <code>String.class</code>），然后是 Hook 回调对象（<code>XC_MethodHook</code>）。</p>
</li>
</ul>
<p>  <strong>作用</strong>：找到 <code>com.zj.wuaipojie.Demo</code> 类中 <strong>形参为 <code>String</code> 的构造方法</strong>，然后 Hook 该构造方法。</p>
<hr>
<h3 id="2-beforeHookedMethod"><a href="#2-beforeHookedMethod" class="headerlink" title="2. beforeHookedMethod"></a><strong>2. beforeHookedMethod</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>    <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>    param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">"CC"</span>;  <span class="hljs-comment">// 修改构造函数的参数</span><br>}<br><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>param.args[0]</code> 代表构造函数的第一个参数。</li>
<li><code>param.args[0] = "CC";</code> 将传入 <code>Demo</code> 类构造函数的 <code>String</code> 参数修改为 <code>"CC"</code>。</li>
</ul>
<p>  <strong>作用</strong>：在 <code>Demo</code> 类构造方法执行前，修改它的参数，使得传入的字符串无论原来是什么，都会变成 <code>"CC"</code>。</p>
<hr>
<h3 id="3-afterHookedMethod"><a href="#3-afterHookedMethod" class="headerlink" title="3. afterHookedMethod"></a><strong>3. afterHookedMethod</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>    <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>afterHookedMethod</code> 发生在构造函数 <strong>执行后</strong>，但本代码没有做额外操作，仅调用 <code>super.afterHookedMethod(param)</code>。</li>
</ul>
<p>  <strong>作用</strong>：在 <code>Demo</code> 对象创建后可以执行其他操作，如修改 <code>this</code> 指向的对象，但本代码未做额外操作。</p>
<h3 id="4-Android-类加载机制"><a href="#4-Android-类加载机制" class="headerlink" title="4. Android 类加载机制"></a><strong>4. Android 类加载机制</strong></h3><p>  <code>loadPackageParam.classLoader</code> 提供的是目标应用的 <code>ClassLoader</code>，常见的类加载器有：</p>
<ul>
<li><code>PathClassLoader</code>：用于加载 <code>APK</code> 内的 <code>dex</code> 文件。</li>
<li><code>DexClassLoader</code>：可以动态加载外部 <code>dex</code> 文件。</li>
</ul>
<p>  <strong>为什么需要提供 <code>classLoader</code>？</strong><br>  因为 <code>Xposed</code> 运行在宿主应用环境（如 <code>Zygote</code>），而 <code>Demo</code> 这个类属于目标应用，因此 <strong>需要使用目标应用的 <code>ClassLoader</code> 加载它</strong>，否则找不到类。</p>
<p>  这段代码适合用于分析 <code>Demo</code> 类的实例创建情况，或者绕过 <code>Demo</code> 可能存在的参数检查逻辑。</p>
</li>
</ul>
<p>  3.对于无参构造函数可以使用替换函数将内容替换。</p>
</li>
</ul>
<h3 id="7-Hook-multiDex方法"><a href="#7-Hook-multiDex方法" class="headerlink" title="7.Hook multiDex方法"></a><strong>7.Hook multiDex方法</strong></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">osedHelpers.findAndHookMethod(Application.class, <span class="hljs-string">"attach"</span>, Context.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ClassLoader cl= ((Context)param.args[<span class="hljs-number">0</span>]).getClassLoader();<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Class&lt;?&gt; hookclass=<span class="hljs-literal">null</span>;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span> {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;hookclass=cl.loadClass(<span class="hljs-string">"类名"</span>);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}<span class="hljs-keyword">catch</span> (Exception e){<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Log.e(<span class="hljs-string">"zj2595"</span>,<span class="hljs-string">"未找到类"</span>,e);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">return</span>;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;XposedHelpers.findAndHookMethod(hookclass, <span class="hljs-string">"方法名"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-meta">@Override</span><br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;}<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;});<br>&nbsp; &nbsp; }<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<p>  1.教程Demo中只有一个Dex文件，但在平常Hook中会有多个甚至几十个这种情况下，如果不在第一个Dex文件夹里面，我们需要先找到相关的类，然后将类传进去再进行普通方法的Hook。</p>
<p>  2.在Dex文件中最多只能存在65535个方法</p>
<ul>
<li><p>代码详解</p>
<h3 id="1-Hook-Application-attach-的意图"><a href="#1-Hook-Application-attach-的意图" class="headerlink" title="1.&nbsp;Hook&nbsp;Application.attach&nbsp;的意图"></a>1.&nbsp;<strong>Hook&nbsp;<code>Application.attach</code>&nbsp;的意图</strong></h3><ul>
<li><p><strong>时机控制</strong>：</p>
<p>  <code>Application.attach(Context)</code>&nbsp;是应用初始化时较早调用的方法，通过在此处获取&nbsp;<code>ClassLoader</code>，确保目标类已加载到内存。</p>
</li>
<li><p><strong>解决类隔离问题</strong>：</p>
<p>  某些应用可能使用多&nbsp;<code>ClassLoader</code>（如插件化框架），直接使用系统&nbsp;<code>ClassLoader</code>&nbsp;可能无法加载目标类。</p>
</li>
</ul>
<h3 id="2-延迟Hook（Lazy-Hook）"><a href="#2-延迟Hook（Lazy-Hook）" class="headerlink" title="2.&nbsp;延迟Hook（Lazy Hook）"></a>2.&nbsp;<strong>延迟Hook（Lazy Hook）</strong></h3><ul>
<li><p><strong>问题背景</strong>：</p>
<p>  若直接Hook目标类的方法，可能因类尚未被加载导致&nbsp;<code>ClassNotFoundException</code>。</p>
</li>
<li><p><strong>解决方案</strong>：</p>
<p>  先Hook&nbsp;<code>Application.attach</code>，在其执行后通过目标应用的&nbsp;<code>ClassLoader</code>&nbsp;加载类，确保类已初始化。</p>
</li>
</ul>
<h3 id="3-ClassLoader-的关键作用"><a href="#3-ClassLoader-的关键作用" class="headerlink" title="3.&nbsp;ClassLoader&nbsp;的关键作用"></a>3.&nbsp;<strong><code>ClassLoader</code>&nbsp;的关键作用</strong></h3><ul>
<li><p><strong>上下文隔离</strong>：</p>
<p>  Android中不同应用（或模块）使用独立的&nbsp;<code>ClassLoader</code>，需通过目标Context获取其&nbsp;<code>ClassLoader</code>&nbsp;才能正确加载类。</p>
</li>
<li><p><strong>示例来源</strong>：</p>
<p>  <code>param.args[0]</code>&nbsp;是&nbsp;<code>attach</code>&nbsp;方法的&nbsp;<code>Context</code>&nbsp;参数，代表当前应用的上下文。</p>
</li>
</ul>
<h3 id="4-动态方法Hook"><a href="#4-动态方法Hook" class="headerlink" title="4.&nbsp;动态方法Hook"></a>4.&nbsp;<strong>动态方法Hook</strong></h3><ul>
<li><p><strong>灵活性与隐蔽性</strong>：</p>
<p>  通过运行时加载类并Hook方法，无需提前知道目标类的具体实现，适用于对抗混淆或动态代码加载（如DexClassLoader）。</p>
</li>
</ul>
<p>  <strong>延迟Hook技术</strong>&nbsp;的典型实现，通过Hook&nbsp;<code>Application.attach</code>&nbsp;方法获取目标&nbsp;<code>ClassLoader</code>，再动态加载并Hook目标类的方法。在安卓逆向中，这种技术常用于：</p>
<ol>
<li>处理混淆后的类和方法。</li>
<li>应对动态代码加载（如热修复、插件化）。</li>
<li>绕过类初始化顺序导致的Hook失败问题。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="8-主动调用"><a href="#8-主动调用" class="headerlink" title="8.主动调用"></a><strong>8.主动调用</strong></h3><p>静态方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">clazz</span> = XposedHelpers.findClass(<span class="hljs-string">"类名"</span>,lpparam.classLoader);<br>XposedHelpers.callStaticMethod(clazz,<span class="hljs-string">"方法名"</span>,参数(非必须));<br></code></pre></td></tr></tbody></table></figure>

<p>实例方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"类名"</span>,lpparam.classLoader);<br>XposedHelpers.callMethod(clazz.newInstance(),<span class="hljs-string">"方法名"</span>,参数(非必须));<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>主动调用方法，同样分为静态方法和动态方法两种。主要看是否有static修饰符。在 Java 中，<code>static</code> 关键字用于修饰 <strong>变量、方法、代码块和内部类</strong>，表示它们属于 <strong>类</strong> 而不是类的实例（对象）。这意味着 <code>static</code> 成员可以在不创建对象的情况下被直接访问。</li>
<li>这是教程Demo中未被调用的函数，我们尝试主动调用该函数</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107874.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>我们发现日志通过主动调用输出</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107778.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码详解</p>
<h3 id="1-XposedHelpers-callMethod-方法"><a href="#1-XposedHelpers-callMethod-方法" class="headerlink" title="1. XposedHelpers.callMethod 方法"></a><strong>1. XposedHelpers.callMethod 方法</strong></h3><ul>
<li><strong>作用</strong>：简化反射调用流程，无需手动获取&nbsp;<code>Method</code>&nbsp;对象。</li>
<li><strong>参数</strong>：<ul>
<li><strong>对象实例</strong>：需先创建目标类的实例。</li>
<li><strong>方法名</strong>：要调用的方法名称。</li>
<li><strong>可变参数</strong>：方法的参数值（可选）。</li>
</ul>
</li>
<li><strong>底层实现</strong>：内部通过反射调用&nbsp;<code>Method.invoke()</code>。</li>
</ul>
<h3 id="2-clazz-newInstance-的限制"><a href="#2-clazz-newInstance-的限制" class="headerlink" title="2. clazz.newInstance() 的限制"></a><strong>2. clazz.newInstance() 的限制</strong></h3><ul>
<li><strong>无参构造要求</strong>：目标类必须存在&nbsp;<strong>public 无参构造函数</strong>。</li>
<li><strong>潜在问题</strong>：<ul>
<li>若构造函数为私有（常见单例模式），抛出&nbsp;<code>InstantiationException</code>。</li>
<li>若构造函数需参数，抛出&nbsp;<code>IllegalArgumentException</code>。</li>
</ul>
</li>
</ul>
<h3 id="3-方法调用的条件"><a href="#3-方法调用的条件" class="headerlink" title="3. 方法调用的条件"></a><strong>3. 方法调用的条件</strong></h3><ul>
<li><strong>方法存在性</strong>：目标类需存在名为&nbsp;<code>refl</code>&nbsp;的方法。</li>
<li><strong>方法签名匹配</strong>：需匹配参数类型和数量（此处未传参，默认调用无参方法）。</li>
<li><strong>访问权限</strong>：若方法为&nbsp;<code>private</code>，需通过&nbsp;<code>setAccessible(true)</code>&nbsp;突破限制。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>findClass("类名", classLoader)</code></td>
<td>查找目标类</td>
</tr>
<tr>
<td><code>callStaticMethod(clazz, "方法名", 参数...)</code></td>
<td>调用静态方法</td>
</tr>
<tr>
<td><code>callMethod(clazz.newInstance(), "方法名", 参数...)</code></td>
<td>创建对象并调用实例方法</td>
</tr>
</tbody></table>
<p>  这些 API 在 <strong>Android 逆向、Xposed Hook、Frida Hook</strong> 中非常常用，主要用于：</p>
<ul>
<li><strong>调用未公开的类和方法</strong>。</li>
<li><strong>绕过安全检测（如 <code>isRooted()</code>、<code>isSecureMode()</code>）</strong>。</li>
<li><strong>伪造 API 返回值（如 <code>getDeviceID()</code>、<code>getToken()</code>）</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-Hook内部类"><a href="#9-Hook内部类" class="headerlink" title="9.Hook内部类"></a><strong>9.Hook内部类</strong></h3><p>内部类:类里还有一个类class</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.Demo$InnerClass"</span>, loadPackageParam.classLoader, <span class="hljs-string">"innerFunc"</span>,String.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>                param.args[<span class="hljs-number">0</span>] = <span class="hljs-string">"CC内部类"</span> ;<br>            }<br>        });<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>Hook类里面还有一个class</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262107682.png" srcset="/img/loading.gif" lazyload></p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108404.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>用$符拼接内部类名</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108310.png" srcset="/img/loading.gif" lazyload></p>
<p>  3.触发内部类的方法</p>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108618.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码解析</p>
<h3 id="1-内部类的Hook方式"><a href="#1-内部类的Hook方式" class="headerlink" title="1. 内部类的Hook方式"></a><strong>1. 内部类的Hook方式</strong></h3><ul>
<li><p><strong>类名格式</strong>：</p>
<p>  内部类的全限定名格式为&nbsp;<strong><code>外部类名$内部类名</code></strong>，例如&nbsp;<code>Demo$InnerClass</code>。</p>
<ul>
<li>匿名内部类命名通常为&nbsp;<code>外部类名$编号</code>（如&nbsp;<code>Demo$1</code>）。</li>
</ul>
</li>
<li><p><strong>访问权限</strong>：</p>
<p>  若内部类为&nbsp;<code>private</code>，Xposed仍可直接Hook，无需额外处理访问权限。</p>
</li>
</ul>
<h3 id="2-方法签名匹配"><a href="#2-方法签名匹配" class="headerlink" title="2. 方法签名匹配"></a><strong>2. 方法签名匹配</strong></h3><ul>
<li><p><strong>参数类型</strong>：</p>
<p>  需严格匹配目标方法的参数列表。此处目标方法&nbsp;<code>innerFunc</code>&nbsp;的签名为&nbsp;<code>void innerFunc(String)</code>。</p>
</li>
<li><p><strong>参数索引</strong>：</p>
<p>  <code>param.args[0]</code>&nbsp;对应方法的第一个参数（非静态方法隐含的&nbsp;<code>this</code>&nbsp;对象不计入参数索引）。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>代码</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>findAndHookMethod("类名", classLoader, "方法名", 参数类型, new XC_MethodHook())</code></td>
<td>Hook 目标类的方法</td>
</tr>
<tr>
<td><code>param.args[0] = "新参数";</code></td>
<td>修改方法参数</td>
</tr>
<tr>
<td><code>param.setResult("新返回值");</code></td>
<td>修改方法返回值</td>
</tr>
<tr>
<td><code>XC_MethodReplacement</code></td>
<td>直接替换方法实现</td>
</tr>
<tr>
<td><code>findClass("外部类$内部类")</code></td>
<td>获取内部类的 <code>Class</code></td>
</tr>
</tbody></table>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li>Hook <strong>加密解密方法</strong>，修改参数/返回值。</li>
<li>Hook <strong>日志打印方法</strong>，截获敏感信息。</li>
<li>Hook <strong>检测方法（如 <code>isRooted()</code>）</strong>，绕过安全校验。</li>
</ul>
<h3 id="1-匿名内部类的Hook"><a href="#1-匿名内部类的Hook" class="headerlink" title="1. 匿名内部类的Hook"></a><strong>1. 匿名内部类的Hook</strong></h3><ul>
<li><p><strong>定位匿名内部类</strong>：</p>
<p>  通过反编译工具查找类名（如&nbsp;<code>Demo$1</code>），或通过代码行为分析确定目标方法。</p>
</li>
<li><p><strong>示例代码</strong>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Hook匿名内部类Demo$1的某个方法</span><br>XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.Demo$1"</span>, classLoader, <span class="hljs-string">"run"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> {<br>        <span class="hljs-comment">// 修改逻辑</span><br>    }<br>});<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="2-静态内部类的处理"><a href="#2-静态内部类的处理" class="headerlink" title="2. 静态内部类的处理"></a><strong>2. 静态内部类的处理</strong></h3><ul>
<li><p><strong>类名格式</strong>：</p>
<p>  静态内部类名为&nbsp;<code>外部类名$静态内部类名</code>，Hook方式与非静态内部类一致。</p>
</li>
<li><p><strong>访问权限</strong>：</p>
<p>  静态内部类无需外部类实例即可访问，可直接实例化。</p>
</li>
</ul>
<h3 id="3-修改非String类型参数"><a href="#3-修改非String类型参数" class="headerlink" title="3. 修改非String类型参数"></a><strong>3. 修改非String类型参数</strong></h3><ul>
<li><p><strong>扩展应用</strong>：</p>
<p>  支持任意类型参数修改（需匹配目标方法签名）。</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改int类型参数</span><br>param.args[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>;<br><br><span class="hljs-comment">// 修改对象类型参数</span><br>param.args[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomObject</span>();<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-反射大法"><a href="#10-反射大法" class="headerlink" title="10.反射大法"></a><strong>10.反射大法</strong></h3><ul>
<li><p>反射基本了解</p>
<p>  <strong>反射（Reflection）</strong> 是 Java 提供的一种 <strong>在运行时动态操作类、方法、字段、构造方法</strong> 的机制。</p>
<p>  在安卓逆向（如 Xposed Hook、Frida、脱壳、动态调试）中，反射是常用技术，尤其是：</p>
<ul>
<li><strong>绕过隐藏 API 限制</strong></li>
<li><strong>调用私有/未公开方法</strong></li>
<li><strong>动态修改/访问类的私有成员</strong></li>
<li><strong>绕过 <code>ProGuard</code> 混淆</strong></li>
</ul>
<h3 id="1-反射的基本原理"><a href="#1-反射的基本原理" class="headerlink" title="1. 反射的基本原理"></a><strong>1. 反射的基本原理</strong></h3><p>  Java 反射主要依赖 <code>java.lang.reflect</code> 包，包含：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class</code></td>
<td>获取类的信息（如方法、字段、构造器）</td>
</tr>
<tr>
<td><code>Method</code></td>
<td>代表类的方法，可用于调用</td>
</tr>
<tr>
<td><code>Field</code></td>
<td>代表类的字段（变量），可用于读写</td>
</tr>
<tr>
<td><code>Constructor</code></td>
<td>代表类的构造方法，可用于实例化对象</td>
</tr>
</tbody></table>
<ul>
<li><strong>反射允许动态访问 &amp; 修改类的成员（方法、变量）</strong></li>
<li><strong>可以绕过 Java 访问权限（私有方法 &amp; 变量）</strong></li>
<li><strong>常用于绕过检测（如 <code>isRooted()</code>、<code>getDeviceID()</code>）</strong></li>
<li><strong>配合 Xposed / Frida 进行逆向分析</strong></li>
<li><strong>Hook <code>Class.forName()</code>、<code>Method.invoke()</code> 可以拦截所有反射调用</strong></li>
</ul>
<h3 id="2-反射的核心API"><a href="#2-反射的核心API" class="headerlink" title="2. 反射的核心API"></a><strong>2. 反射的核心API</strong></h3><table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>用途</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Class.forName(String)</code></td>
<td>动态加载类</td>
<td><code>Class&lt;?&gt; clazz = Class.forName("com.example.Target");</code></td>
</tr>
<tr>
<td><code>clazz.getDeclaredMethod()</code></td>
<td>获取方法（包括私有）</td>
<td><code>Method method = clazz.getDeclaredMethod("methodName", paramTypes);</code></td>
</tr>
<tr>
<td><code>method.setAccessible(true)</code></td>
<td>突破访问权限限制</td>
<td><code>method.setAccessible(true);</code></td>
</tr>
<tr>
<td><code>method.invoke(Object,args)</code></td>
<td>调用方法</td>
<td><code>method.invoke(instance, arg1, arg2);</code></td>
</tr>
<tr>
<td><code>clazz.getDeclaredField()</code></td>
<td>获取字段（包括私有）</td>
<td><code>Field field = clazz.getDeclaredField("fieldName");</code></td>
</tr>
<tr>
<td><code>field.set(Object, value)</code></td>
<td>修改字段值</td>
<td><code>field.set(instance, newValue);</code></td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, lpparam.classLoader);<br>XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.Demo$InnerClass"</span>, lpparam.classLoader, <span class="hljs-string">"innerFunc"</span>,String.class,&nbsp;&nbsp;<span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//第一步找到类</span><br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//找到方法，如果是私有方法就要setAccessible设置访问权限</span><br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-comment">//invoke主动调用或者set修改值(变量)</span><br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<span class="hljs-type">Class</span> <span class="hljs-variable">democlass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>,<span class="hljs-literal">false</span>,lpparam.classLoader);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">demomethod</span> <span class="hljs-operator">=</span> democlass.getDeclaredMethod(<span class="hljs-string">"refl"</span>);<br>                demomethod.setAccessible(<span class="hljs-literal">true</span>);<br>                demomethod.invoke(clazz.newInstance());<br>&nbsp; &nbsp; }<br>});<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>查找目标类，Hook内部类方法并在回调中反射调用另一个方法</li>
<li>有修饰符，说明它是一个私有的方法，需要先将权限设置为true，然后再通过invoke来实现主动调用</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108154.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>实例需要先通过API找到当前类名的字节码，传<code>clazz.newInstance()</code>来作为一个实例，通过反射来进行主动调用。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262108773.png" srcset="/img/loading.gif" lazyload></p>
<p>  4.如果不通过主动调用，而是set值来进行一个修改</p>
<ul>
<li><p>代码解析</p>
<h3 id="1-XposedHelpers的作用"><a href="#1-XposedHelpers的作用" class="headerlink" title="1. XposedHelpers的作用"></a><strong>1. XposedHelpers的作用</strong></h3><ul>
<li><strong>简化Hook流程</strong>：封装反射API，直接通过类名和方法名进行Hook。</li>
<li><strong>自动处理ClassLoader</strong>：使用目标应用的&nbsp;<code>lpparam.classLoader</code>，避免类加载隔离问题。</li>
</ul>
<h3 id="2-内部类的Hook"><a href="#2-内部类的Hook" class="headerlink" title="2. 内部类的Hook"></a><strong>2. 内部类的Hook</strong></h3><ul>
<li><strong>命名规则</strong>：内部类的全限定名为&nbsp;<code>外部类名$内部类名</code>，如&nbsp;<code>Demo$InnerClass</code>。</li>
<li><strong>逆向意义</strong>：内部类常包含关键业务逻辑（如加密、校验），Hook后可干预执行流程。</li>
</ul>
<h3 id="3-反射调用私有方法"><a href="#3-反射调用私有方法" class="headerlink" title="3. 反射调用私有方法"></a><strong>3. 反射调用私有方法</strong></h3><ul>
<li><strong>核心步骤</strong>：<ol>
<li><strong>加载目标类</strong>：<code>Class.forName()</code>&nbsp;或&nbsp;<code>XposedHelpers.findClass</code>。</li>
<li><strong>获取方法对象</strong>：<code>getDeclaredMethod("refl")</code>（假设无参）。</li>
<li><strong>突破访问限制</strong>：<code>setAccessible(true)</code>。</li>
<li><strong>创建实例并调用</strong>：<code>invoke(clazz.newInstance())</code>。</li>
</ol>
</li>
<li><strong>逆向应用</strong>：主动调用私有方法可绕过正常逻辑触发敏感操作（如生成密钥、解锁功能）。</li>
</ul>
<h3 id="4-动态实例化对象"><a href="#4-动态实例化对象" class="headerlink" title="4. 动态实例化对象"></a><strong>4. 动态实例化对象</strong></h3><ul>
<li><strong><code>clazz.newInstance()</code>&nbsp;的限制</strong>：<ul>
<li><p>要求目标类有&nbsp;<strong>public无参构造函数</strong>，否则抛出&nbsp;<code>InstantiationException</code>。</p>
</li>
<li><p>若构造函数为私有，需使用&nbsp;<code>XposedHelpers.newInstance()</code>&nbsp;替代：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例：强制调用私有构造方法</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> XposedHelpers.newInstance(clazz);<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-Xposed-Hook-机制"><a href="#2-Xposed-Hook-机制" class="headerlink" title="2. Xposed Hook 机制"></a><strong>2. Xposed Hook 机制</strong></h2><h3 id="①-findClass-：查找类"><a href="#①-findClass-：查找类" class="headerlink" title="① findClass()：查找类"></a><strong>① <code>findClass()</code>：查找类</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, lpparam.classLoader);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a><strong>相关知识点</strong></h3><ul>
<li><code>XposedHelpers.findClass(className, classLoader)</code>：<ul>
<li><p>作用：在目标应用的 <code>ClassLoader</code> 里查找 <code>com.zj.wuaipojie.Demo</code> 类。</p>
</li>
<li><p><code>lpparam.classLoader</code>：由 <code>Xposed</code> 提供，确保加载的是目标应用的类。</p>
</li>
<li><p><strong>等效的 Java 代码：</strong></p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, <span class="hljs-literal">false</span>, lpparam.classLoader);<br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="②-findAndHookMethod-：Hook-内部类的方法"><a href="#②-findAndHookMethod-：Hook-内部类的方法" class="headerlink" title="② findAndHookMethod()：Hook 内部类的方法"></a><strong>② <code>findAndHookMethod()</code>：Hook 内部类的方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<br>    <span class="hljs-string">"com.zj.wuaipojie.Demo$InnerClass"</span>,<br>    lpparam.classLoader,<br>    <span class="hljs-string">"innerFunc"</span>,<br>    String.class,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>            <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="相关知识点-1"><a href="#相关知识点-1" class="headerlink" title="相关知识点"></a><strong>相关知识点</strong></h3><ul>
<li><code>findAndHookMethod(className, classLoader, methodName, paramTypes..., XC_MethodHook)</code>：<ul>
<li>作用：Hook 目标类的方法，修改 <code>innerFunc(String)</code> 的执行行为。</li>
<li><strong><code>com.zj.wuaipojie.Demo$InnerClass</code></strong>：<ul>
<li><code>$</code> 表示 <strong>内部类</strong>，即 <code>InnerClass</code> 是 <code>Demo</code> 类的 <strong>成员内部类</strong>。</li>
<li><code>InnerClass</code> 必须是 <strong>非静态（非 static）</strong>，否则它的 <code>this</code> 需要 <code>Demo</code> 实例。</li>
</ul>
</li>
<li><code>beforeHookedMethod()</code>：<ul>
<li><strong>在原方法执行前</strong> 运行，可以 <strong>修改参数、拦截执行</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-Java-反射调用-Demo-refl"><a href="#3-Java-反射调用-Demo-refl" class="headerlink" title="3. Java 反射调用 Demo.refl()"></a><strong>3. Java 反射调用 <code>Demo.refl()</code></strong></h2><h3 id="③-Class-forName-：通过反射查找类"><a href="#③-Class-forName-：通过反射查找类" class="headerlink" title="③ Class.forName()：通过反射查找类"></a><strong>③ <code>Class.forName()</code>：通过反射查找类</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">democlass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, <span class="hljs-literal">false</span>, lpparam.classLoader);<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="相关知识点-2"><a href="#相关知识点-2" class="headerlink" title="相关知识点"></a><strong>相关知识点</strong></h3><ul>
<li><code>Class.forName(className, initialize, classLoader)</code>：<ul>
<li><p><strong>作用</strong>：动态加载 <code>Demo</code> 类，<code>false</code> 代表 <strong>不触发静态初始化</strong>。</p>
</li>
<li><p><strong>等效的 Xposed 方法</strong>：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = XposedHelpers.findClass(<span class="hljs-string">"com.zj.wuaipojie.Demo"</span>, lpparam.classLoader);<br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="④-getDeclaredMethod-：获取私有方法"><a href="#④-getDeclaredMethod-：获取私有方法" class="headerlink" title="④ getDeclaredMethod()：获取私有方法"></a><strong>④ <code>getDeclaredMethod()</code>：获取私有方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">demomethod</span> <span class="hljs-operator">=</span> democlass.getDeclaredMethod(<span class="hljs-string">"refl"</span>);<br>demomethod.setAccessible(<span class="hljs-literal">true</span>);<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="相关知识点-3"><a href="#相关知识点-3" class="headerlink" title="相关知识点"></a><strong>相关知识点</strong></h3><ul>
<li><strong><code>getDeclaredMethod(methodName, 参数类型...)</code></strong><ul>
<li><strong>作用</strong>：查找 <code>refl()</code> 方法（包括 <code>private</code>）。</li>
<li><strong>区别</strong>：<ul>
<li><code>getMethod()</code>：只能获取 <code>public</code> 方法。</li>
<li><code>getDeclaredMethod()</code>：可获取 <code>private</code> / <code>protected</code> 方法。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>setAccessible(true)</code></strong><ul>
<li>解除 Java 访问权限，允许调用 <code>private</code> 方法。</li>
<li><strong>绕过 ProGuard 混淆</strong>：<ul>
<li>即使 <code>refl()</code> 被混淆成 <code>a()</code>，仍可通过反射调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="⑤-invoke-：反射调用-refl-方法"><a href="#⑤-invoke-：反射调用-refl-方法" class="headerlink" title="⑤ invoke()：反射调用 refl() 方法"></a><strong>⑤ <code>invoke()</code>：反射调用 <code>refl()</code> 方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">demomethod.invoke(clazz.newInstance());<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="相关知识点-4"><a href="#相关知识点-4" class="headerlink" title="相关知识点"></a><strong>相关知识点</strong></h3><ul>
<li><strong><code>invoke(对象, 参数...)</code></strong><ul>
<li><p>作用：在 <code>clazz.newInstance()</code> 对象上调用 <code>refl()</code> 方法。</p>
</li>
<li><p><code>clazz.newInstance()</code> 等价于：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">demoInstance</span> <span class="hljs-operator">=</span> democlass.getConstructor().newInstance();<br>demomethod.invoke(demoInstance);<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>注意：</strong></p>
<ul>
<li><p><code>newInstance()</code> 只能用于 <strong>无参构造方法</strong>。</p>
</li>
<li><p>如果 <code>Demo</code> 没有无参构造方法，应使用：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Constructor&lt;?&gt; constructor = democlass.getDeclaredConstructor(String.class);<br>constructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">demoInstance</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">"参数"</span>);<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-遍历所有类下的所有方法"><a href="#11-遍历所有类下的所有方法" class="headerlink" title="11.遍历所有类下的所有方法"></a><strong>11.遍历所有类下的所有方法</strong></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(ClassLoader.class, <span class="hljs-string">"loadClass"</span>, String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>                <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> (Class) param.getResult();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">clazzName</span> <span class="hljs-operator">=</span> clazz.getName();<br>                <span class="hljs-comment">//排除非包名的类</span><br>                <span class="hljs-keyword">if</span>(clazzName.contains(<span class="hljs-string">"com.zj.wuaipojie"</span>)){<br>                    Method[] mds = clazz.getDeclaredMethods();<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;mds.length; i++){<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">Method</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> mds[i];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> mds[i].getModifiers();<br>                    <span class="hljs-comment">//去除抽象、native、接口方法</span><br>                        <span class="hljs-keyword">if</span>(!Modifier.isAbstract(mod)<br>                            &amp;&amp; !Modifier.isNative(mod)<br>                            &amp;&amp; !Modifier.isInterface(mod)){<br>                            XposedBridge.hookMethod(mds[i], <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                                    <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>                                    Log.d(<span class="hljs-string">"zj2595"</span>,md.toString());<br>                                }<br>                            });<br>                        }<br>                    }<br>                }<br>            }<br>        });<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>将加载该界面时所用的方法加载遍历了出来</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109554.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码解析</p>
<h3 id="1-Hook-ClassLoader-loadClass-的意图"><a href="#1-Hook-ClassLoader-loadClass-的意图" class="headerlink" title="1. Hook&nbsp;ClassLoader.loadClass&nbsp;的意图"></a><strong>1. Hook&nbsp;<code>ClassLoader.loadClass</code>&nbsp;的意图</strong></h3><ul>
<li><strong>动态监控类加载</strong>：在类被加载到内存时触发回调，实时捕获目标类的所有方法。</li>
<li><strong>逆向价值</strong>：<ul>
<li>批量Hook混淆后的类和方法（无需提前知道具体名称）。</li>
<li>跟踪应用初始化流程，定位关键逻辑（如加密、网络请求）。</li>
</ul>
</li>
</ul>
<h3 id="2-方法过滤逻"><a href="#2-方法过滤逻" class="headerlink" title="2. 方法过滤逻"></a><strong>2. 方法过滤逻</strong></h3><ul>
<li><strong>排除抽象方法</strong>：抽象方法无实际代码，Hook无意义。</li>
<li><strong>排除Native方法</strong>：Native方法（JNI实现）无法通过Java层Hook。</li>
<li><strong>排除接口方法</strong>：接口方法由实现类具体定义，直接Hook接口可能导致重复拦截。</li>
</ul>
<h3 id="3-动态插桩（Instrumentation）"><a href="#3-动态插桩（Instrumentation）" class="headerlink" title="3. 动态插桩（Instrumentation）"></a><strong>3. 动态插桩（Instrumentation）</strong></h3><ul>
<li><strong>技术本质</strong>：在目标方法执行前/后插入自定义代码（如日志、参数修改）。</li>
<li><strong>逆向应用</strong>：<ul>
<li>监控方法调用顺序，分析代码执行流程</li>
<li>动态修改方法参数或返回值（需在<code>beforeHookedMethod</code>中操作）。</li>
</ul>
</li>
</ul>
<h3 id="1-Hook-ClassLoader-loadClass"><a href="#1-Hook-ClassLoader-loadClass" class="headerlink" title="(1) Hook ClassLoader.loadClass()"></a><strong>(1) Hook <code>ClassLoader.loadClass()</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<br>    ClassLoader.class,<br>    <span class="hljs-string">"loadClass"</span>,<br>    String.class,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>            <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用"><a href="#🔹-作用" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p><strong>Hook <code>ClassLoader.loadClass(String)</code> 方法</strong>，在类被加载后执行自定义逻辑。</p>
</li>
<li><p><strong>等效 Java 代码：</strong></p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> getClass().getClassLoader();<br>Class&lt;?&gt; clazz = classLoader.loadClass(<span class="hljs-string">"com.example.MyClass"</span>);<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>Xposed Hook 方式：</strong></p>
<ul>
<li><code>afterHookedMethod()</code> 确保 <code>loadClass()</code> 方法执行后，我们可以获取到被加载的 <code>Class&lt;?&gt;</code> 对象。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-获取-loadClass-结果（即新加载的类）"><a href="#2-获取-loadClass-结果（即新加载的类）" class="headerlink" title="(2) 获取 loadClass() 结果（即新加载的类）"></a><strong>(2) 获取 <code>loadClass()</code> 结果（即新加载的类）</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> (Class) param.getResult();<br><span class="hljs-type">String</span> <span class="hljs-variable">clazzName</span> <span class="hljs-operator">=</span> clazz.getName();<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-1"><a href="#🔹-作用-1" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><code>param.getResult()</code>：获取 <code>loadClass(String)</code> 的返回值，即 <code>Class&lt;?&gt;</code> 对象。</li>
<li><code>clazz.getName()</code>：获取类名，例如 <code>"com.zj.wuaipojie.Demo"</code>。</li>
</ul>
<hr>
<h3 id="3-过滤目标包名"><a href="#3-过滤目标包名" class="headerlink" title="(3) 过滤目标包名"></a><strong>(3) 过滤目标包名</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(clazzName.contains(<span class="hljs-string">"com.zj.wuaipojie"</span>)) {<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-2"><a href="#🔹-作用-2" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p>只 Hook 目标应用的类，避免 Hook 系统类（如 <code>android.*</code>）。</p>
</li>
<li><p>这里使用了 <code>contains()</code>，可以优化为：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(clazzName.startsWith(<span class="hljs-string">"com.zj.wuaipojie"</span>))<br></code></pre></td></tr></tbody></table></figure>
<p>  这样能 <strong>精确匹配包名开头</strong>，减少误判。</p>
</li>
</ul>
<hr>
<h3 id="4-获取-clazz-的所有方法"><a href="#4-获取-clazz-的所有方法" class="headerlink" title="(4) 获取 clazz 的所有方法"></a><strong>(4) 获取 <code>clazz</code> 的所有方法</strong></h3><h3 id="🔹-作用-3"><a href="#🔹-作用-3" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p>获取 <strong>所有</strong> 方法，包括 <code>private</code>、<code>protected</code> 和 <code>public</code> 方法。</p>
</li>
<li><p><strong>等效 Java 代码：</strong></p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Method[] methods = clazz.getDeclaredMethods();<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h3 id="5-遍历方法，筛选可-Hook-方法"><a href="#5-遍历方法，筛选可-Hook-方法" class="headerlink" title="(5) 遍历方法，筛选可 Hook 方法"></a><strong>(5) 遍历方法，筛选可 Hook 方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mds.length; i++) {<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Method</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> mds[i];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> mds[i].getModifiers();<br>    <span class="hljs-comment">// 去除抽象、native、接口方法</span><br>    <span class="hljs-keyword">if</span> (!Modifier.isAbstract(mod)<br>        &amp;&amp; !Modifier.isNative(mod)<br>        &amp;&amp; !Modifier.isInterface(mod)) { <br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-4"><a href="#🔹-作用-4" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li>过滤掉无法直接 Hook 的方法：<ul>
<li><code>Modifier.isAbstract(mod)</code>：抽象方法不能直接 Hook。</li>
<li><code>Modifier.isNative(mod)</code>：<code>native</code> 方法需要 Frida 或 JNI Hook。</li>
<li><code>Modifier.isInterface(mod)</code>：接口方法不能 Hook。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-Hook-选定的方法"><a href="#6-Hook-选定的方法" class="headerlink" title="(6) Hook 选定的方法"></a><strong>(6) Hook 选定的方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedBridge.hookMethod(mds[i], <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>        <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>        Log.d(<span class="hljs-string">"zj2595"</span>, md.toString());<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-5"><a href="#🔹-作用-5" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p><strong>Hook 目标方法</strong>，在方法执行前打印方法签名：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Log.d(<span class="hljs-string">"zj2595"</span>, md.toString());<br></code></pre></td></tr></tbody></table></figure>
<p>  这将在 Logcat 里输出：</p>
  <figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">D/zj2595: public void com<span class="hljs-selector-class">.zj</span><span class="hljs-selector-class">.wuaipojie</span><span class="hljs-selector-class">.Demo</span><span class="hljs-selector-class">.testMethod</span>()<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-Xposed妙用"><a href="#12-Xposed妙用" class="headerlink" title="12.Xposed妙用"></a><strong>12.Xposed妙用</strong></h3><p>字符串赋值定位:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"android.widget.TextView"</span>, loadPackageParam.classLoader, <span class="hljs-string">"setText"</span>, CharSequence.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br>                Log.d(<span class="hljs-string">"zj2595"</span>, param.args[<span class="hljs-number">0</span>].toString());<br>                <span class="hljs-keyword">if</span> (param.args[<span class="hljs-number">0</span>].equals(<span class="hljs-string">"已过期"</span>)) {<br>                    printStackTrace();<br>                }<br>            }<br>        });<br>    }<br>    <span class="hljs-comment">//堆栈调用</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStackTrace</span><span class="hljs-params">()</span> {<br>            <span class="hljs-type">Throwable</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>();<br>            StackTraceElement[] stackElements = ex.getStackTrace();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stackElements.length; i++) {<br>                <span class="hljs-type">StackTraceElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> stackElements[i];<br>                Log.d(<span class="hljs-string">"zj2595"</span>,<span class="hljs-string">"at "</span> + element.getClassName() + <span class="hljs-string">"."</span> + element.getMethodName() + <span class="hljs-string">"("</span> + element.getFileName() + <span class="hljs-string">":"</span> + element.getLineNumber() + <span class="hljs-string">")"</span>);<br>            }<br>        }<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>找到方法后，先输出一下，查看是什么字符串进行的settext</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109236.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>对字符串进行过滤，输出堆栈，我们发现调用settext的是oncreate方法，如果要修改字符串通过堆栈调用找到该方法，对字符串及进行修改。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109960.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码详解</p>
<h3 id="1-Hook-TextView-setText"><a href="#1-Hook-TextView-setText" class="headerlink" title="(1) Hook TextView.setText()"></a><strong>(1) Hook <code>TextView.setText()</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<br>    <span class="hljs-string">"android.widget.TextView"</span>,<br>    lpparam.classLoader,<br>    <span class="hljs-string">"setText"</span>,<br>    CharSequence.class,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>            <span class="hljs-built_in">super</span>.beforeHookedMethod(param);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-6"><a href="#🔹-作用-6" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><strong>拦截 <code>TextView.setText(CharSequence)</code> 方法</strong>，用于监控 App 内的 <strong>所有 UI 文本更新</strong>。</li>
<li><code>param.args[0]</code> 代表 <code>setText()</code> 传入的文本内容。</li>
</ul>
<hr>
<h3 id="2-记录-setText-的内容"><a href="#2-记录-setText-的内容" class="headerlink" title="(2) 记录 setText() 的内容"></a><strong>(2) 记录 <code>setText()</code> 的内容</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Log.d(<span class="hljs-string">"zj2595"</span>, param.args[<span class="hljs-number">0</span>].toString());<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-7"><a href="#🔹-作用-7" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p>打印 <code>TextView</code> 设置的文本，例如：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">D/zj2595: 试用期已过<br>D/zj2595: 请更新到最新版<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<hr>
<h3 id="3-检测目标文本-已过期"><a href="#3-检测目标文本-已过期" class="headerlink" title="(3) 检测目标文本 &quot;已过期&quot;"></a><strong>(3) 检测目标文本 <code>"已过期"</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (param.args[<span class="hljs-number">0</span>].equals(<span class="hljs-string">"已过期"</span>)) {<br>    printStackTrace();<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-8"><a href="#🔹-作用-8" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><strong>如果文本是 <code>"已过期"</code>，调用 <code>printStackTrace()</code> 打印调用栈</strong>，帮助分析是谁调用了 <code>setText()</code> 方法。</li>
</ul>
<hr>
<h3 id="4-打印调用栈"><a href="#4-打印调用栈" class="headerlink" title="(4) 打印调用栈"></a><strong>(4) 打印调用栈</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStackTrace</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Throwable</span>();<br>    StackTraceElement[] stackElements = ex.getStackTrace();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stackElements.length; i++) {<br>        <span class="hljs-type">StackTraceElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> stackElements[i];<br>        Log.d(<span class="hljs-string">"zj2595"</span>, <span class="hljs-string">"at "</span> + element.getClassName() + <span class="hljs-string">"."</span> + element.getMethodName() + <span class="hljs-string">"("</span> + element.getFileName() + <span class="hljs-string">":"</span> + element.getLineNumber() + <span class="hljs-string">")"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-9"><a href="#🔹-作用-9" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p>创建 <code>Throwable</code> 对象，获取当前方法的 <strong>调用堆栈</strong>（Stack Trace）。</p>
</li>
<li><p>遍历 <code>StackTraceElement[]</code>，打印方法调用路径，例如：</p>
  <figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">D/zj2595: at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MainActivity</span><span class="hljs-selector-class">.onCreate</span>(MainActivity<span class="hljs-selector-class">.java</span>:<span class="hljs-number">42</span>)<br>D/zj2595: at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Activity</span><span class="hljs-selector-class">.performCreate</span>(Activity<span class="hljs-selector-class">.java</span>:<span class="hljs-number">789</span>)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>帮助分析是谁在 <code>setText("已过期")</code>，进而找到业务逻辑！</strong></p>
</li>
</ul>
<h3 id="关键API说明"><a href="#关键API说明" class="headerlink" title="关键API说明"></a><strong>关键API说明</strong></h3><ul>
<li><p><strong><code>param.args[0]</code></strong>：</p>
<p>  <code>setText</code>&nbsp;方法的第一个参数（<code>CharSequence</code>&nbsp;类型），即要显示的文本内容。</p>
</li>
<li><p><strong><code>Throwable.getStackTrace()</code></strong>：</p>
<p>  获取当前线程的调用堆栈，用于追踪方法调用层级。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>点击事件监听:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">claz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"android.view.View"</span>, loadPackageParam.classLoader);<br>        XposedBridge.hookAllMethods(clazz, <span class="hljs-string">"performClick"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>                <span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">listenerInfoObject</span> <span class="hljs-operator">=</span> XposedHelpers.getObjectField(param.thisObject, <span class="hljs-string">"mListenerInfo"</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">mOnClickListenerObject</span> <span class="hljs-operator">=</span> XposedHelpers.getObjectField(listenerInfoObject, <span class="hljs-string">"mOnClickListener"</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">callbackType</span> <span class="hljs-operator">=</span> mOnClickListenerObject.getClass().getName();Log.d(<span class="hljs-string">"zj2595"</span>,callbackType);<br>            }<br>        });<br><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>我们可以发现点击按钮后的方法被打印出来</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262109835.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码解析</p>
<h3 id="1-Hook-View-performClick"><a href="#1-Hook-View-performClick" class="headerlink" title="(1) Hook View.performClick()"></a><strong>(1) Hook <code>View.performClick()</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> XposedHelpers.findClass(<span class="hljs-string">"android.view.View"</span>, lpparam.classLoader);<br>XposedBridge.hookAllMethods(clazz, <span class="hljs-string">"performClick"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹作用"><a href="#🔹作用" class="headerlink" title="🔹作用"></a><strong>🔹作用</strong></h3><ul>
<li><code>performClick()</code> 是 <strong>所有点击事件的核心方法</strong>，最终会触发 <code>OnClickListener.onClick(View v)</code> 方法。</li>
<li><strong>通过 Hook <code>performClick()</code>，可以拦截所有 <code>View</code> 的点击事件，获取具体的 <code>OnClickListener</code> 监听器</strong>。</li>
</ul>
<hr>
<h3 id="2-获取-View-的-mListenerInfo"><a href="#2-获取-View-的-mListenerInfo" class="headerlink" title="(2) 获取 View 的 mListenerInfo"></a><strong>(2) 获取 <code>View</code> 的 <code>mListenerInfo</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">listenerInfoObject</span> <span class="hljs-operator">=</span> XposedHelpers.getObjectField(param.thisObject, <span class="hljs-string">"mListenerInfo"</span>);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-10"><a href="#🔹-作用-10" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><strong><code>View</code> 并不会直接存储 <code>OnClickListener</code>，而是放在 <code>mListenerInfo</code> 这个内部对象中</strong>。</li>
<li>这里 <strong>通过 Xposed 反射 <code>getObjectField()</code> 读取 <code>mListenerInfo</code> 对象</strong>，它是 <code>View.ListenerInfo</code> 类的实例，包含 <code>mOnClickListener</code> 字段。</li>
</ul>
<hr>
<h3 id="3-获取-mOnClickListener"><a href="#3-获取-mOnClickListener" class="headerlink" title="(3) 获取 mOnClickListener"></a><strong>(3) 获取 <code>mOnClickListener</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">mOnClickListenerObject</span> <span class="hljs-operator">=</span> XposedHelpers.getObjectField(listenerInfoObject, <span class="hljs-string">"mOnClickListener"</span>);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-11"><a href="#🔹-作用-11" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><strong>从 <code>mListenerInfo</code> 中获取 <code>mOnClickListener</code> 字段</strong>，即实际处理点击事件的 <code>OnClickListener</code> 实例。</li>
<li>这个 <code>mOnClickListenerObject</code> <strong>就是 <code>View.setOnClickListener()</code> 绑定的 <code>OnClickListener</code> 实现类</strong>。</li>
</ul>
<hr>
<h3 id="4-打印-OnClickListener-的实现类"><a href="#4-打印-OnClickListener-的实现类" class="headerlink" title="(4) 打印 OnClickListener 的实现类"></a><strong>(4) 打印 <code>OnClickListener</code> 的实现类</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">callbackType</span> <span class="hljs-operator">=</span> mOnClickListenerObject.getClass().getName();<br>Log.d(<span class="hljs-string">"zj2595"</span>, callbackType);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-12"><a href="#🔹-作用-12" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p>通过 <code>mOnClickListenerObject.getClass().getName()</code> 获取 <strong><code>OnClickListener</code> 的真实类名</strong>。</p>
</li>
<li><p><strong>用于分析 <code>View</code> 点击事件的具体处理逻辑</strong>，例如：</p>
  <figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">D/zj2595: <span class="hljs-keyword">com</span>.example.MainActivity<span class="hljs-number">$1</span><br></code></pre></td></tr></tbody></table></figure>
<p>  这里的 <code>com.example.MainActivity$1</code> 表示 <code>OnClickListener</code> 是 <code>MainActivity</code> 的匿名内部类。</p>
</li>
</ul>
<h3 id="1-Hook-View-performClick-的意图"><a href="#1-Hook-View-performClick-的意图" class="headerlink" title="1. Hook&nbsp;View.performClick&nbsp;的意图"></a><strong>1. Hook&nbsp;<code>View.performClick</code>&nbsp;的意图</strong></h3><ul>
<li><strong>监控点击事件</strong>：捕获所有View的点击操作（按钮、列表项等），分析用户交互行为。</li>
<li><strong>定位点击处理逻辑</strong>：通过监听器类型追踪到具体实现类（如Activity、匿名内部类），辅助逆向工程师快速定位关键代码。</li>
</ul>
<h3 id="2-反射获取私有字段"><a href="#2-反射获取私有字段" class="headerlink" title="2. 反射获取私有字段"></a><strong>2. 反射获取私有字段</strong></h3><ul>
<li><p><strong>字段访问</strong>：</p>
<p>  <code>mListenerInfo</code>&nbsp;和&nbsp;<code>mOnClickListener</code>&nbsp;均为View的私有字段，通过&nbsp;<code>XposedHelpers.getObjectField</code>&nbsp;突破访问限制。</p>
</li>
<li><p><strong>逆向意义</strong>：</p>
<p>  直接访问私有字段可绕过常规方法（如<code>View.getListenerInfo()</code>），避免触发潜在的反调试检测。</p>
</li>
</ul>
<h3 id="3-监听器类型分析"><a href="#3-监听器类型分析" class="headerlink" title="3. 监听器类型分析"></a><strong>3. 监听器类型分析</strong></h3><ul>
<li><strong>常见类型</strong>：<ul>
<li><strong>匿名内部类</strong>：<code>MainActivity$1</code>（自动生成的类名）。</li>
<li><strong>Lambda表达式</strong>：<code>$$Lambda$MainActivity$Xo4wq...</code>（ProGuard混淆后名称）。</li>
<li><strong>Activity自身实现</strong>：<code>com.example.MainActivity</code>（实现&nbsp;<code>View.OnClickListener</code>&nbsp;接口）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>改写布局:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.ui.ChallengeSixth"</span>, lpparam.classLoader,<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-string">"onCreate"</span>, Bundle.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br>&nbsp; &nbsp; <span class="hljs-meta">@Override</span><br>&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable {<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-built_in">super</span>.afterHookedMethod(param);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span class="hljs-type">View</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> (View)XposedHelpers.callMethod(param.thisObject,<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; <span class="hljs-string">"findViewById"</span>, <span class="hljs-number">0x7f0800de</span>);<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;img.setVisibility(View.GONE);<br><br>&nbsp; &nbsp; }<br>});<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>示例</p>
<ol>
<li>在onCreate方法中我们可以找到一些布局的绑定，如button控件等内容都是在onCreate方法中实例。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110935.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>传入控件16进制的值</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110214.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>我们会发现原来这部分的图片已经被隐藏起来</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110524.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>代码解析</p>
<h3 id="1-Hook-Activity-onCreate的意图"><a href="#1-Hook-Activity-onCreate的意图" class="headerlink" title="1. Hook Activity.onCreate的意图"></a><strong>1. Hook Activity.onCreate的意图</strong></h3><ul>
<li><strong>篡改UI初始化</strong>：在Activity创建时修改界面布局，隐藏或替换关键元素（如验证提示、广告）。</li>
<li><strong>绕过界面限制</strong>：例如隐藏“未授权”提示，直接展示功能界面。</li>
</ul>
<h3 id="2-资源ID的逆向定位"><a href="#2-资源ID的逆向定位" class="headerlink" title="2. 资源ID的逆向定位"></a><strong>2. 资源ID的逆向定位</strong></h3><ul>
<li><strong>资源ID格式</strong>：<code>0x7f0800de</code>&nbsp;表示APK资源ID，通常对应&nbsp;<code>R.id.xxx</code>。</li>
<li><strong>逆向定位方法</strong>：<ol>
<li><strong>反编译工具</strong>：使用 Jadx/Ghidra 查找&nbsp;<code>R.java</code>&nbsp;或资源映射表，将ID转换为具体名称（如&nbsp;<code>R.id.btn_submit</code>）。</li>
<li><strong>动态调试</strong>：通过Android Studio的Layout Inspector实时查看界面元素ID。</li>
</ol>
</li>
</ul>
<h3 id="3-动态调用findViewById"><a href="#3-动态调用findViewById" class="headerlink" title="3. 动态调用findViewById"></a><strong>3. 动态调用findViewById</strong></h3><ul>
<li><p><strong>反射调用</strong>：通过&nbsp;<code>XposedHelpers.callMethod</code>&nbsp;直接调用Activity的&nbsp;<code>findViewById</code>&nbsp;方法，等价于：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> ((Activity) param.thisObject).findViewById(<span class="hljs-number">0x7f0800de</span>);<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>逆向意义</strong>：无需修改APK代码，动态操控UI元素。</p>
</li>
</ul>
<h3 id="1-Hook-onCreate-方法"><a href="#1-Hook-onCreate-方法" class="headerlink" title="(1) Hook onCreate() 方法"></a><strong>(1) Hook <code>onCreate()</code> 方法</strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">XposedHelpers.findAndHookMethod(<span class="hljs-string">"com.zj.wuaipojie.ui.ChallengeSixth"</span>, lpparam.classLoader,<br>&nbsp; &nbsp; <span class="hljs-string">"onCreate"</span>, Bundle.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">XC_MethodHook</span>() {<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-13"><a href="#🔹-作用-13" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><strong>目标类：</strong> <code>com.zj.wuaipojie.ui.ChallengeSixth</code></li>
<li><strong>目标方法：</strong> <code>onCreate(Bundle savedInstanceState)</code></li>
<li><strong>Hook <code>onCreate()</code> 的原因：</strong><ul>
<li><code>onCreate()</code> 是 <code>Activity</code> 生命周期的入口，通常在这里进行 UI 初始化。</li>
<li><strong>Hook 该方法可以拦截 UI 初始化过程，并修改 <code>View</code> 的属性</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-获取-View"><a href="#2-获取-View" class="headerlink" title="(2) 获取 View"></a><strong>(2) 获取 <code>View</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> (View) XposedHelpers.callMethod(param.thisObject,<br>&nbsp; &nbsp; <span class="hljs-string">"findViewById"</span>, <span class="hljs-number">0x7f0800de</span>);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-14"><a href="#🔹-作用-14" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p><strong>通过 <code>findViewById()</code> 获取 ID 为 <code>0x7f0800de</code> 的 <code>View</code> 对象</strong>。</p>
</li>
<li><p><code>param.thisObject</code> 代表 <code>ChallengeSixth</code> 实例，相当于：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> ((Activity) param.thisObject).findViewById(<span class="hljs-number">0x7f0800de</span>);<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>0x7f0800de</code> 是一个 <code>View ID</code>，可以通过 <code>R.id.xxx</code> 解析：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">viewId</span> <span class="hljs-operator">=</span> R.id.targetView;  <span class="hljs-comment">// 例如：R.id.imageView</span><br></code></pre></td></tr></tbody></table></figure>
<p>  在 Xposed Hook 代码中通常只能使用 <code>ID 值</code>（<code>0x7fxxxxxx</code>），而不能用 <code>R.id.xxx</code>。</p>
</li>
</ul>
<hr>
<h3 id="3-隐藏-View"><a href="#3-隐藏-View" class="headerlink" title="(3) 隐藏 View"></a><strong>(3) 隐藏 <code>View</code></strong></h3>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">img.setVisibility(View.GONE);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="🔹-作用-15"><a href="#🔹-作用-15" class="headerlink" title="🔹 作用"></a><strong>🔹 作用</strong></h3><ul>
<li><p>将目标 <code>View</code> <strong>设置为 <code>GONE</code>（完全隐藏，不占空间）</strong>。</p>
</li>
<li><p><code>View</code> 的可见性状态：</p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">View.VISIBLE   <span class="hljs-comment">// 可见</span><br>View.INVISIBLE <span class="hljs-comment">// 隐藏但仍占空间</span><br>View.GONE      <span class="hljs-comment">// 完全隐藏，不占空间</span><br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>等效 Java 代码：</strong></p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ImageView</span> <span class="hljs-variable">img</span> <span class="hljs-operator">=</span> findViewById(R.id.targetView);<br>img.setVisibility(View.GONE);<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Xposed模块patch"><a href="#Xposed模块patch" class="headerlink" title="Xposed模块patch"></a><strong>Xposed模块patch</strong></h2><p><a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPatch">LSPatch</a></p>
<p>PS:最低支持安卓9</p>
<ul>
<li><p>将项目编译为apk过程示例</p>
<ol>
<li>点击build选择apk</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110526.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>先新建一个签名信息文件，生成一个.jks文件</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262110007.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>配置后让应用可以发布选择release建立</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111278.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>建立好后我们发现目录中可以查看到release文件和生成的apk</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111409.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>我们在路径下找到我们新生成的apk</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111522.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>在LSPatch中选择我们教程Demo进行修补</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111688.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>我们使用便携模式嵌入模块（在没有root的手机中也可以使用）</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111531.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>修补后因为暂时缺少模块我们手动安装一下该模块</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111017.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>我们发现图标消失，说明它在运行时已经加载了相关模块</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262111492.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h3 id="Xposed快速Hook"><a href="#Xposed快速Hook" class="headerlink" title="Xposed快速Hook"></a><strong>Xposed快速Hook</strong></h3><p><a target="_blank" rel="noopener" href="https://github.com/littleWhiteDuck/SimpleHook">SimpleHook</a></p>
<ul>
<li><p>使用方法示例</p>
<ol>
<li>安装好<a target="_blank" rel="noopener" href="https://github.com/littleWhiteDuck/SimpleHook%E5%AF%B9%E6%83%B3%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E7%9B%AE%E6%A0%87%E8%BF%9B%E8%A1%8C%E5%8B%BE%E9%80%89%E8%AE%BE%E7%BD%AE">https://github.com/littleWhiteDuck/SimpleHook对想要进行操作的目标进行勾选设置</a></li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112026.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>在设置中将smail转化为配置打开，然后回到首页进行添加配置。在MT管理器中找到方法签名进行复制。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112037.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>smail自动填充之后，我们进行参返实践。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112296.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>保存同意root权限后，将配置打开，我们打开apk后可以在记录处得到参返。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262112559.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>同理我们还可以进行Hook参数值并进行修改等操作。</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262113404.png" srcset="/img/loading.gif" lazyload>
  </p>
</li>
<li><p>Hook变量示例</p>
<ol>
<li>Hook实例变量，同上先复制签名进行相关配置</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/CC-NX/blogImage/main//_img/202503262113351.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>可以发现没有修改前是300</li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/Xposed-Modules-Repo/me.jsonet.jshook">jshook</a></p>
<h3 id="Xpsoed源码"><a href="#Xpsoed源码" class="headerlink" title="Xpsoed源码"></a><strong>Xpsoed源码</strong></h3><p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1149210-1-1.html">XPOSED魔改一：获取特征</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1694093-1-1.html">Lsposed 技术原理探讨 &amp;&amp; 基本安装使用</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269616.htm#msg_header_h2_0">[原创]源码编译（2）——Xopsed源码编译详解</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Android%E9%80%86%E5%90%91/" class="category-chain-item">Android逆向</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Frida/" class="print-no-link">#Frida</a>
      
        <a href="/tags/Xposd/" class="print-no-link">#Xposd</a>
      
        <a href="/tags/API/" class="print-no-link">#API</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Xposd模块编写，API详解</div>
      <div>https://cc-nx.github.io/2025/03/26/ZJ7,8/Xposd模块编写，API详解 1baa6f4b4daf802c9edfdb04c625b4b5/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CC</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/01/ZJ9/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AE%97%E6%B3%95%E8%87%AA%E5%90%90%EF%BC%8C%E9%9D%9E%E6%A0%87%E5%87%86%E5%8A%A0%E5%AF%86%E5%AF%B9%E6%8A%97%201c3a6f4b4daf803eb988f970e5d95436/" title="密码学基础，算法自吐">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">密码学基础，算法自吐</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/23/ZJ6/%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%201b2a6f4b4daf80b3891ddef3c55cac14/" title="签名校验">
                        <span class="hidden-mobile">签名校验</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
